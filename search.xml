<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[call 函数的理解]]></title>
    <url>%2Fcall%E5%87%BD%E6%95%B0%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[call() 用来改变this的指向，先来看下call函数的用法。123456789101112function fn()&#123; console.log(this.a, this.b);&#125;fn(); // undefined undefinedlet c = &#123; 'a': 12, 'b': 24&#125;fn.call(c); // 12 24 再来看下这个小栗子（原文地址：https://www.cnblogs.com/donghezi/p/9742778.html）123456789101112function fn1() &#123; console.log('fn1----', this);&#125;function fn2() &#123; console.log('fn2-----', this);&#125;fn1.call(fn2); //fn1---- function fn2() &#123; 重点一 // console.log('fn2-----', this); //&#125; 结合上边的例子，再来看下这个。12345678910111213// ES6 call 实现Function.prototype.es6Call = function (context) &#123; var context = context || window; context.fn = this; var args = []; for (var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; const result = context.fn(...args); delete context.fn; return result;&#125;//原文：https://blog.csdn.net/u010377383/article/details/80646415 这里的 context.fn = this; this其实就是上边例子输出的 fn2函数.args.push(&#39;arguments[&#39; + i + &#39;]&#39;); 相当于是在数组中放入了[ arguments[1], arguments[2], ... ]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令]]></title>
    <url>%2Fgit%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一些命令，用的时候记得牢牢的。过一段时间不用就忘记了，这里记录一下git的命令及其使用 拉取把远程分支的代码pull到本地分支：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 连接已有仓库git remote add origin &lt;https://github.com/OliveKong/poster.git&gt; 删除删除远程分支： git push oirgin –delete [branch name]删除本地分支： git branch -d [branch name] 恢复恢复： git reflog 查看版本号恢复： git reset –hard [版本号] 分支新建在本地新建一个分支： git branch 切换到你的新分支: git checkout 将新分支发布在github上： git push origin 拉取 情况一：目前本地还没拉代码，直接拉分支代码 git clone -b &lt;you branchName&gt; &lt;you git path&gt; 情况二：本地已经拉取了代码，想拉取远程某一分支的代码到本地git checkout -b &lt;branch name&gt; origin/&lt;branch name&gt; 拉取远程分支到本地(方式一)git fetch origin &lt;branch name&gt;:&lt;branch name&gt; 拉取远程分支到本地(方式二) 方式一有可能出现错误提示： fatal: &#39;origin/ac_branch&#39; is not a commit and a branch &#39;ac_branch&#39; cannot be created from it 解决方式: 执行命令：git fetch 同步一下仓库 最容易出错的操作 git checkout -b ac_branch 这是在当前分支上创建一个ac_branch分支 git checkout -b ac_branch origin/ac_branch 这才是拉取远程分支ac_branch到本地 方式一、二的区别方式一做了三件事： 1、拉取远程分支到本地 2、在本地创建一个分支与远程分支对应 3、自动切换到刚创建好的分支 方式二做了三件事： 1、同步远程仓库（git fetch origin） 2、拉取远程分支到本地 3、在本地创建一个分支与远程分支对应 新建仓库提交代码正确步骤： git init //初始化仓库 git add .(文件name) //添加文件到本地仓库 git commit -m “first commit” //添加文件描述信息 git remote add origin + 远程仓库地址 //链接远程仓库，创建主分支 git pull origin master // 把本地仓库的变化连接到远程仓库主分支 git push -u origin master //把本地仓库的文件推送到远程仓库 参考：https://www.jianshu.com/p/16e35060c64e]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HexoNext 深度自定义，修改样式及布局]]></title>
    <url>%2FHexoNext%2F</url>
    <content type="text"><![CDATA[找找找，改改改。想要了解一个东西必须要折腾。折腾的多了就明白他是怎么一回事了！！ 修改导航样式设置导航图标与文字水平显示, 如下代码第四行最后面theme/next/layout/_macro/menu/menu-item.swig1234567891011121314&lt;li class=&quot;menu-item menu-item-&#123;&#123; itemName | replace(&apos; &apos;, &apos;-&apos;, &apos;g&apos;) &#125;&#125;&#123;&#123; item_active(itemURL, &apos;menu-item-active&apos;) &#125;&#125;&quot;&gt; &lt;a href=&quot;&#123;&#123; url_for(itemURL) &#125;&#125;&quot; rel=&quot;section&quot;&gt; &#123;%- if theme.menu_settings.icons %&#125; &lt;i class=&quot;menu-item-icon fa fa-fw fa-&#123;&#123; value.split(&apos;||&apos;)[1] | trim | default(&apos;question-circle&apos;) &#125;&#125;&quot;&gt;&lt;/i&gt; 这里的&lt;br /&gt;去掉 &#123;# #&#125;&#123;% endif %&#125; &#123;&#123;- __(&apos;menu.&apos; + name ) | replace(&apos;menu.&apos;, &apos;&apos;) -&#125;&#125; &#123;%- if theme.menu_settings.badges -%&#125; &#123;&#123;- menu_badge.render(name) | trim -&#125;&#125; &#123;%- endif -%&#125; &lt;/a&gt; &lt;/li&gt; 还有一个搜索的需要单独去掉themes\next6\layout\_partials\header\menu.swig123456789101112&lt;li class=&quot;menu-item menu-item-search&quot;&gt; &#123;% if theme.swiftype_key %&#125; &lt;a href=&quot;javascript:;&quot; class=&quot;st-search-show-outputs&quot;&gt; &#123;% elseif theme.local_search.enable || theme.algolia_search.enable %&#125; &lt;a href=&quot;javascript:;&quot; class=&quot;popup-trigger&quot;&gt; &#123;% endif %&#125; &#123;% if theme.menu_settings.icons %&#125; &lt;i class=&quot;menu-item-icon fa fa-search fa-fw&quot;&gt;&lt;/i&gt; &#123;# 直接注释或者删除即可 &lt;br /&gt; #&#125;&#123;# #&#125;&#123;% endif %&#125;&#123;# #&#125;&#123;&#123; __(&apos;menu.search&apos;) &#125;&#125;&#123;##&#125;&lt;/a&gt;&lt;/li&gt; 接入网页在线联系功能 首先在DaoVoice注册个账号，点击-&gt;邀请码是2e5d695d。 完成后，会得到一个app_id，后面会用到： 修改/themes/next/layout/_partials/head.swig文件，添加内容如下：123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice") daovoice('init', &#123; app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;" &#125;); daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; 复制以上代码,放到下图俩红框之间 在 主题配置_config.yml文件中添加内容：123# Online contactdaovoice: truedaovoice_app_id: # 这里填你刚才获得的 app_id 自定义about页面（完完全全的自定义）首先要创建about页面（使用官方方式）1hexo new page "about" 这个时候在博客目录/source/ 下就会出现 about 文件夹，编辑里面的 index.md 文件，添加：123456---title: 关于date: 2018-03-12 17:44:53type: "about"comments: false # 此处为禁用评论功能， 如果你想有评论 设置为true或者去掉该行代码即可。--- 接下来说下实现自定义具体步骤： 打开主题目录 在 layout 文件夹下新建 about.swig wen 打开主题目录下的 layout/page.swig 大概10多行 1234567891011121314151617&#123;% block title %&#125;&#123;# #&#125;&#123;% set page_title_suffix = ' | ' + title %&#125;&#123;# #&#125;&#123;% if page.type === "categories" and not page.title %&#125;&#123;# #&#125;&#123;&#123; __('title.category') + page_title_suffix &#125;&#125;&#123;# #&#125;&#123;% elif page.type === "tags" and not page.title %&#125;&#123;# #&#125;&#123;&#123; __('title.tag') + page_title_suffix &#125;&#125;&#123;# &#123;# 添加下面两行代码 #&#125; #&#125;&#123;% elif page.type === "about" and not page.title %&#125;&#123;# #&#125;&#123;&#123; __('title.about') + page_title_suffix &#125;&#125;&#123;# #&#125;&#123;% else %&#125;&#123;# #&#125;&#123;&#123; page.title + page_title_suffix &#125;&#125;&#123;# #&#125;&#123;% endif %&#125;&#123;##&#125;&#123;% endblock %&#125; 接下来往下大概50行左右的位置添加： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div class="post-body&#123;% if theme.han %&#125; han-init-context&#123;% endif %&#125;&#123;% if page.direction &amp;&amp; page.direction.toLowerCase() === 'rtl' %&#125; rtl&#123;% endif %&#125;"&gt; &#123;# tagcloud page support #&#125; &#123;% if page.type === "tags" %&#125; &lt;div class="tag-cloud"&gt; &lt;div class="tag-cloud-title"&gt; &#123;% set visibleTags = 0 %&#125; &#123;% for tag in site.tags %&#125; &#123;% if tag.length %&#125; &#123;% set visibleTags += 1 %&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;&#123; _p('counter.tag_cloud', visibleTags) &#125;&#125; &lt;/div&gt; &lt;div class="tag-cloud-tags"&gt; &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 300, color: true, start_color: '#ccc', end_color: '#111'&#125;) &#125;&#125; &lt;/div&gt; &lt;/div&gt; &#123;% elif page.type === 'categories' %&#125; &lt;div class="category-all-page"&gt; &lt;div class="category-all-title"&gt; &#123;% set visibleCategories = 0 %&#125; &#123;% for cat in site.categories %&#125; &#123;% if cat.length %&#125; &#123;% set visibleCategories += 1 %&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;&#123; _p('counter.categories', visibleCategories) &#125;&#125; &lt;/div&gt; &lt;div class="category-all"&gt; &#123;&#123; list_categories() &#125;&#125; &lt;/div&gt; &lt;/div&gt; &#123;# 此处添加判断是否为about #&#125; &#123;% elif page.type === 'about' %&#125; &lt;div class="about-page"&gt; 这里放你的代码 我是曹二丽 &lt;/div&gt; &#123;% else %&#125; &#123;&#123; page.content &#125;&#125; &#123;% endif %&#125;&lt;/div&gt; 自此，你已经可以自定义about页面的布局等等了。问题（可能你没有，如果有的话来瞅瞅）： 页面的title 例如标签页面是 标签|八小时之外 所添加的about页面的title可能是 |八小时之外问题解决： 打开主题目录的 languages/zh-CN.yml,在 title 下添加: 12345678910111213---title: archive: 归档 category: 分类 tag: 标签 about: 关于 # 这里添加一下即可！ schedule: 日程表menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 如果你觉得在里面写感觉太混乱不够清晰，可以在主题目录 layout 下新建一个 about.swig在刚才的位置引入此模板, 这样你就可以在模板里面你的代码了。 12345678910111213141516171819202122232425262728293031323334 &#123;% elif page.type === 'categories' %&#125; &lt;div class="category-all-page"&gt; &lt;div class="category-all-title"&gt; &#123;% set visibleCategories = 0 %&#125; &#123;% for cat in site.categories %&#125; &#123;% if cat.length %&#125; &#123;% set visibleCategories += 1 %&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;&#123; _p('counter.categories', visibleCategories) &#125;&#125; &lt;/div&gt; &lt;div class="category-all"&gt; &#123;&#123; list_categories() &#125;&#125; &lt;/div&gt; &lt;/div&gt; &#123;# 此处添加判断是否为about #&#125; &#123;% elif page.type === 'about' %&#125; &lt;div class="about-page"&gt; 这里放你的代码 我是曹二丽 &lt;/div&gt; &#123;# 引入模板 #&#125; &#123;% include 'about.swig' %&#125; &#123;% else %&#125; &#123;&#123; page.content &#125;&#125; &#123;% endif %&#125;&lt;/div&gt; 如果你想在about.swig里面使用page.swig里面的变量。只需引入的时候这样：/page.swig12&#123;% set foo = &#123; bar: &quot;baz&quot; &#125; %&#125; &#123;# 这里在上下文定义一个对象 #&#125;&#123;% include &apos;about.swig&apos; with foo%&#125; 这样在about.swig文件就可以拿到传过去的数据了。/about.swig1&#123;&#123; foo.bar &#125;&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[400万北漂女孩爆红朋友圈，背后的真相却让人泪奔了...]]></title>
    <url>%2F18-10-12%2F</url>
    <content type="text"><![CDATA[本文使用 Python 实现网络爬虫爬取数据…最近，一部叫《北京女子图鉴》的电视剧刷爆了整个朋友圈。这部剧讲的是大学毕业生陈可依只身北上打拼的故事。本以为这样一部剧能引起不少在大城市独自奋斗的女孩子的共鸣，没想到很多姑娘看完都炸了：“导演你是不是对女性有什么误解？” 标榜着“独立自强”的女主，职场每一次升迁，都是傍着男人；嘴上说着“想要什么自己去赚”，收起土豪老总送的香水倒是心安理得。身边的闺蜜唯一信奉的生活哲理就是“一张床可以奋斗出一套房”。就连剧里唯一成功的女老总，房产也是靠离婚的补偿金买的。 打着女权的旗号，却在鼓励女性靠脂粉、靠衣服博取利益，无限地夸大颜值、关系、小聪明的作用，殊不知这一切都狠狠侮辱和讽刺了那些靠自己的智慧、实力和努力来赢得地位的女性。 真正在大城市拼搏的女孩子，从来不是这样的。 ／／01／／曾经见过这样一张照片。凌晨两点的街道上，一个女孩蹲在路中间崩溃大哭。那一刻，一定是有什么东西最后压垮了她，让她活不下去了。而在大城市，这样的深夜痛哭，还有很多。认识一个编剧，一毕业就做了北漂。刚来的时候穷得只能住在半地下室里。冬天没有暖气，睡觉的时候把所有棉衣都盖在身上；夏天极潮，雨一大，半截窗户就开始漏水，得用脸盆接着。就这样苦撑两年，等来的不是机会，而是异地男友的微信：我们分手吧，我等不起了。苦吗？这就是大部分北漂姑娘的日常。谁没住过几次地下室，谁没住过一间合租房，谁没被黑中介坑过，谁没被房东突然涨过房租？可再苦，还是坚持了下来，哪怕每一个微笑的背后，都是咬紧牙关的灵魂。／／02／／ 朋友圈里有一个妹子，头像是樊胜美，配上字幕：“在上海生活不容易啊”。 在外企上班的她，每天压力大到一把一把掉头发。从小没被爸妈说过一句重话，工作之后整天被领导骂，被客户折磨。熬夜加班成了常事，有一次竟然在公交车上站着睡着了，还自嘲反正超挤，睡着也不会摔倒。没有时间做饭，整天吃着油腻的外卖，常常胃疼到脸色发白。 最盼望的事，就是升职加薪，努力攒钱在这座城市买一个小房子，成为这个城市里真正的一员。可不管怎么努力，工资永远追不上房价。 有一次下班时下雨了，她为了省下打车钱，缩在站台等了半个小时的公交。远远地，她看着一个和她年纪相仿的妹子上了一辆法拉利。 这就是大城市，有人一出生就拥有你从没有过的东西，而有人必须用力奔跑才赶上别人的起跑线。最难的从来不是买房，而是实现阶层的跨越。 ／／03／／ 闺蜜来深圳有些年头了。她是销售出身，每天接电话无数，却说自己最害怕接的，就是爸妈的电话。因为每次都是催婚。 有一次，被逼到不行的她也去参加了相亲会。在那个小小的相亲角上，她看到每个人都近乎耻辱地举着一块牌子，在上面把自己物化成一套房子、一辆车、一个本地户口… 在大城市，连感情都多了很多衡量。 而她就像很多打拼的外地女孩一样，无房无车，不是本地户口，不具备任何一项可以在婚姻市场上进行博弈的条件。最可怕的是，她连唯一的资本——年轻，也马上失去了。 所以大城市的女孩子更急迫、更焦虑，不是担心无人可嫁，而是怕自己成长的速度，敌不过自己变老的速度。 ／／04／／你看，这才是最真实的“大城市女子图鉴。”生活从不天真，它不会套着粉红色滤镜给你演玛丽苏剧。 那位编剧朋友，苦熬了十年，才有了今天的江湖地位。朋友圈里的上海妹子，吃了几年的外卖才做到公司中层，靠着期权和投资，勉强付了房子的首付。闺蜜自从看清了现实，更是一心扑到工作上，她说：“脱单和脱贫，至少完成一个。”在大城市的弱肉强食里，一个女孩子要付出更多，才能换来一点进步。 , 记得看过这样一段话：“如果这时候有人抱抱我，我是一定会哭一哭的，如果没有的话，那我就再坚持一下。我要先做一个披荆斩棘无所不能的女英雄，直到遇见能托付一生的人，才能再做一个瓶盖都拧不开的小公主。” 在冷漠的大城市里，从来不是你撒撒娇、掉掉泪就能一步登天的。有多少姑娘，关了灯在合租房里失声痛哭；有多少女孩子，故作坚强，其实还是脆弱的孩子… 所有人都看到了你蓬勃的野心，不容小觑的实力，很少有人关心你疲惫的一声叹息。亲爱的姑娘，女英雄做久了，别忘了去疼爱自己，也给别人一个机会，来心疼你。 那个因为忙工作，在计划表里躺了很久的海岛之旅，不如就成行吧。就当给自己放一个假，就当给这么努力的自己，一个小小的奖励。 那个一个人活成一支队伍的自己，那个万事不求人的自己，不如慢慢放松，让别人也有机会来照顾你。 原文地址点击跳转因阅读颇有感触故转载…本文转载自【习惯打卡】App 如有侵权请联系本人删除！]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next5.x 升级6.x]]></title>
    <url>%2F18-10-06%2F</url>
    <content type="text"><![CDATA[今天开通了阅读次数和评论功能，也添加上了Top榜。 本文记录一下本人升级到6.x时遇到的问题以及解决办法。在next目录中的package.json 可以查看版本信息等… 首先下载 next 6.x 下载压缩包。解压并重名为 next ，放入 themes 目录。把之前的next文件改名为next5主要是为了区分版本，可以随时改回5.x版本。 在更新或者安装Hexo时报错错误如下：12345678910npm ERR! path C:\Users\10167\AppData\Roaming\npm\node_modules\hexo-cli\node_modules\has-value\node_modules\isobjectnpm ERR! code ENOENTnpm ERR! errno -4058npm ERR! syscall accessnpm ERR! enoent ENOENT: no such file or directory, access 'C:\Users\10167\AppData\Roaming\npm\node_modules\hexo-cli\node_modules\has-value\node_modules\isobject'npm ERR! enoent This is related to npm not being able to find a file.npm ERR! enoentnpm ERR! A complete log of this run can be found in:npm ERR! C:\Users\10167\AppData\Roaming\npm-cache\_logs\2018-10-08T03_48_08_101Z-debug.log 问题原因为(疑是)：npm官方镜像连不通的问题。解决方法：使用淘宝镜像http://npm.taobao.org/ 123npm config set registry "https://registry.npm.taobao.org" //将npm包源指向淘宝//然后使用cnpm install -g hexo 一切OK， 现在美化一下博客。 简体中文在 NexT 6 中，简体中文的名称变为 zh-CN ，因此在 博客配置文件 里需要将原有的：123language: zh-Hans# 改为language: zh-CN 背景动画Canvas_nest设置无效的解决方案进入theme/next目录 执行命令：1git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest 这时将配置文件_config.yml中的canvas_nest: false改为canvas_nest: true才能真正生效。如果要使用JavaScript 3D library则执行下面命令1git clone https://github.com/theme-next/theme-next-three source/lib/canvas-nest 而后设置相应的动画效果为true即可：123456# three_wavesthree_waves: false # 海浪# canvas_linescanvas_lines: false # 长线# canvas_spherecanvas_sphere: false # 爆炸 站点建立时间打开themes/next/下的_config.yml，查找since1234footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 #设置为自己想设置的时间 设置头像打开themes/next/下的_config.yml，查找avatar1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: http://XXXXXXXXX avatar的值是图片的链接地址(完整的URI 或者 站内的相对地址皆可)将图片放至themes/next/source/images/配置为：avatar: /images/图片名; 文章底部带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将#换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;如果刷新无效的话执行命令hexo clean后在执行hexo s即可。 点击出现桃心效果复制代码1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在/themes/next/source/js/src里面新建love.js把代码粘贴进来，然后在\themes\next\layout\_layout.swig文件末尾添加以下代码：12&lt;!-- 页面点击小红心 --&gt; &lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 设置网站图标默认的网站图标是一个N，找一个图片将其放在/themes/next/source/images里面，修改下面对应的名字1234567favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png # 这里 apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 主页文章加阴影打开\themes\next\source\css\_custom\custom.styl,向里面加入：12345678// 主页文章添加阴影效果.post &#123;margin-top: 60px;margin-bottom: 60px;padding: 25px;-webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);-moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; \themes\next\source\css\_custom\custom.styl,文件会覆盖所有自带的样式，可以放心的写自己的样式。不想要的时候直接删除就行，不会影响原有的样式。 添加“本文结束”标记在 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：12345&lt;div&gt;&#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;&#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout_macro\post.swig文件，在post-body 之后， 添加以下代码：12345678910&#123;#####################&#125;&#123;### END POST BODY ###&#125;&#123;#####################&#125; 在这个后面添加 &lt;div&gt;&#123;% if not is_index %&#125;&#123;% include 'passage-end-tag.swig' %&#125;&#123;% endif %&#125;&lt;/div&gt; 修改作者头像并旋转打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ animation: play 2s infinite; /* 鼠标经过头像旋转360度 -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;*/&#125;img:hover &#123; /* 鼠标经过停止头像旋转*/ -webkit-animation-play-state:paused; animation-play-state:paused; /* 鼠标经过头像旋转360度 -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg); */&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 添加统计在next\_config.yml文件找到12345678910busuanzi_count: enable: true # 设置为true即可 total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye people: 人数 number: 数量 自定义页脚，相关文件themes\next\layout_third-party\analytics\busuanzi-counter.swig12345678910111213&#123;% if theme.busuanzi_count.total_visitors %&#125;&lt;span class="site-uv" title="&#123;&#123; __('footer.total_visitors') &#125;&#125;"&gt; 这里 &#123;&#123; theme.busuanzi_count.people &#125;&#125; 到这 &lt;i class="fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;"&gt;&lt;/i&gt; &lt;span class="busuanzi-value" id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.busuanzi_count.total_views %&#125;&lt;span class="site-pv" title="&#123;&#123; __('footer.total_views') &#125;&#125;"&gt; 这里 &#123;&#123; theme.busuanzi_count.number &#125;&#125; 到这 &lt;i class="fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;"&gt;&lt;/i&gt; &lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/span&gt;&lt;/span&gt;&#123;% endif %&#125; 之后想要改文字直接在next里改就行了。 文章加密访问如果写点日记什么的还有用，不然纯属好玩。打开themes/next/layout/_partials/head/head.swig文件,在以下位置插入这样一段代码：12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 在写文章的时候加上password如下：1234567---title: Hexo Next5.x 升级6.x date: 2018-10-06 12:53:31tags: [Hexo]categories: Hexopassword: 123456--- 文章置顶12345678---title: Hexo Next5.x 升级6.x date: 2018-10-06 12:53:31tags: [Hexo]categories: Hexopassword: 123456top: true //添加top属性设置为true即可--- 推荐一个大佬的文章点击跳转]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3 media的使用及其兼容]]></title>
    <url>%2Fmedia%2F</url>
    <content type="text"><![CDATA[利用css判断不同分辨率显示不同宽度布局实现自适应宽度即 css3 @media样式的使用CSS 语法12345678910@media mediatype and|not|only (media feature) &#123; CSS-Code;&#125;mediatype 取值： all -&gt; 用于所有设备 print -&gt; 用于打印机和打印预览 screen -&gt; 用于电脑屏幕，平板电脑，智能手机等。 speech -&gt; 应用于屏幕阅读器等发声设备 菜鸟教程显示其他的都已经弃用，便不再罗列。 media type的几种使用方法方法一&lt;link href=&quot;style.css&quot; media=&quot;screen print&quot; ...方法二&lt;?xml-stylesheet media=&quot;screen&quot; href=&quot;style.css&quot;...方法三@import url(&quot;style.css&quot;) screen;方法四123&lt;style media="screen"&gt;@import url("style.css");&lt;/style&gt; 方法五123@media screen&#123;selector&#123;rules&#125;&#125; 当然，这几种方法各有利弊，而我们常用的是第一种和最后一种方法。 media querycss属性判断可以只是某个CSS属性的名称，也可以是属性+值：1&lt;link rel="stylesheet" media="screen and (animation)” herf=“…” 如果设备支持CSS动画，那么就能执行这个外部样式表文件。 媒体查询语句结构我们可以将上述语句称为媒体查询语句，这样也更能理解一些。从上面的例子也可以看出，媒体查询语句一般由media type+一到多个CSS属性判断组成，而多个CSS属性判断可以用关键字and连接：123456@media screen and (min-width:1024px) and (max-width:1280px)&#123; body&#123;font-size:20px;&#125;&#125;@media screen and (min-width:800px),print and (min-width:7in)&#123;body&#123;font-size:small;&#125;&#125; 可理解为 在宽度为1024 - 1280之间 使用 body{font-size:20px;}index.html123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;style&gt; .abc&#123; height:300px; border:1px solid #000; margin:0 auto&#125; @media screen and (min-width: 1201px) &#123; .abc &#123;width: 1200px&#125; &#125; /* css 注释说明：设置了浏览器宽度不小于1201px时 abc 显示1200px宽度 */ @media screen and (max-width: 1200px) &#123; .abc &#123;width: 900px&#125; &#125; /* 设置了浏览器宽度不大于1200px时 abc 显示900px宽度 */ @media screen and (max-width: 900px) &#123; .abc &#123;width: 200px;&#125; &#125; /* 设置了浏览器宽度不大于900px时 abc 显示200px宽度 */ @media screen and (max-width: 500px) &#123; .abc &#123;width: 100px;&#125; &#125; /* 设置了浏览器宽度不大于500px时 abc 显示100px宽度 */ &lt;/style&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="abc"&gt;DIVCSS5实例：我这个DIV宽度会随浏览器宽度变化哦，试试改变浏览器宽度&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 实例地址 IE9以下版本不支持CSS3技术，可以使用加入一个google的JS123&lt;!--[if lt IE 9]&gt; &lt;script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; 以上内容转载自：http://www.divcss5.com/jiqiao/j662.shtmlhttp://www.cnblogs.com/august-8/p/4537685.html]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo - swig语法及其入门]]></title>
    <url>%2Fswig%2F</url>
    <content type="text"><![CDATA[本文档长期更新…由于在自定义博客的时候难免会遇到.swig 文件 但又不知道其语法及其含义。故很难改动…在这里本人亲测以及百度记录一下语法及其用法。 语法 __(‘’, ‘’) 格式化字符串1&#123;&#123; __('footer.powered', '&lt;a class="theme-link" target="_blank"' + nofollow + ' href="https://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125; footer.powered 在zh-CN.yml 中赋值为 &quot;由 %s 强力驱动&quot;因此猜测此语法很有可能是 格式化字符串 类似Python的 print(&#39;hellow %s&#39; % &#39;二丽&#39;)亲测：123&#123;&#123; __("我 %s 曹永强", '是') &#125;&#125;输出我 是 曹永强 注释12&#123;# ...注释内容... #&#125;&#123;# __('footer.powered', '&lt;a class="theme-link" target="_blank"' + nofollow + ' href="https://hexo.io"&gt;Hexo&lt;/a&gt;') #&#125; 条件判断12&#123;% if true %&#125; 显示 &#123;% endif %&#125;&#123;% if false %&#125; 不显示 &#123;% endif %&#125; 标签里面还可以是 for 变量 等. 模板引入其实这些官网都有，只是没有特别标注，不容易找到…引入模板：12345&#123;% include "xxx.html/swig/..." %&#125;// 如果引入的模板想用当前模板的数据//使用 with&#123;% include "about.swig" with object %&#125;// 这样就可以在about.swig 文件中使用 object 对象的数据了]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>swig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通勤，正在“杀死”1000万北京青年]]></title>
    <url>%2F10-09-27%2F</url>
    <content type="text"><![CDATA[p img { width: 100% !omportant;}有人“凌晨三点不回家”，有人“清晨五点已上路”。 数据显示，北京是全国最先醒来的城市。清晨五点，人们已经在为通勤奔波。 人潮一早从东南西北的四五六环涌入城市中心，又在晚间回归，这是属于北京的潮汐。 在北京，人们平均每天上班超过一个半马（26.4Km）：“只是到公司，已耗尽我所有力气”、“业余生活是什么？到家只想平躺，因为已经11点了”—— 这是“大城市有多大”系列第一篇: 北京，如同一支狂想曲，写满了繁华与怀旧，也充满了喧嚣与孤独，人们在这里追寻梦想，也在这里被现实打败，漫长的通勤时间就是多数北京青年每日要面对的残酷现实。 不在北京，很难想象凌晨五点摸黑去上班的感觉。但是，大数据显示，凌晨五点，北京就已经迎来了一日的喧嚣。 支付宝出品的《数说中国人的夜生活》中显示，北京人凌晨5点就开始打车，是全国所有城市中最早的。 每天天还未亮就有几百万人已经醒来，从沙河、天通苑、燕郊、亦庄、良乡、苹果园、北安河，四面八方涌入五环内，开始他们一天的工作。 《2018中国城市通勤研究报告》显示，北京市的平均通勤距离和时间最长（极光大数据出品）。 开车or公交，各有各的艰辛 半梦半醒间，在拥挤的地铁中摇晃两个小时，再阳光乐观的人心里都会有愤怒、委屈，是什么造就了这的窘境？ 车太多，是所有人的第一直觉。 截止2017年6月，北京和上海的平均汽车保有量（数据来源：智研咨询、北京市统计局、上海市统计局） 北京人均汽车保有量这么高，不完全是市场调节的结果。 在两千年后，为了鼓励汽车产业发展，政府出台了不少买车的优惠措施，北京的汽车就是从那时候开始迅速多了起来的。 直到堵车情况非常严重以后，又突然开始实施摇号政策。但是，摇号并没有有效遏制住北京汽车的数量。 没有迫切需求的人在利益的驱动下参与摇号，导致很多有真正用车需求的人反而摇不到号，他们只能开河北牌照的汽车，或者继续摇号，变相增加了路上汽车的行驶量，加重了北京的拥堵情况。 然而让北京青年挤破脑袋也想摇到号的重要原因是北京公共交通体系不够健全，比起在地铁公交上“跋山涉水”，他们宁愿在拥堵的进京高速上“浪费”生命。 早上7点，西二旗地铁站挤满了人。 等了四趟地铁，被挤得东倒西歪，来了北京已经一年多莉娜依旧难以适应，也曾想过“老娘不挤了，住4环内去，”但是深夜看看高昂的房价，还是秒怂了，叹一口气，赶紧睡，第二天还要早起。 早高峰的西二旗地铁站 北京地铁如此拥挤仅仅是人多造成的吗？是的，但不全是。 北京和东京都面积大，常住人口多，但是东京的公共交通出行率远高于北京，在很大程度上缓解了城市的出行压力。 北京公交出行率远低的锅不能全甩到市民公交出行意识不足上，更多是北京公共交通的槽点实在太多。 首先，车站密度不够，远没有达到一个国际大都会应有的水平。 澎湃新闻2018年2月发布的数据显示，北京的地铁车站密度仅为0.02，密度最高的欧洲城市巴黎是北京的38倍，密度最高的亚洲城市首尔是北京的25倍。 即使住在核心城区，也经常面临这样的尴尬：周围三四个地铁站，但距离都在1公里以上。 除了地铁站密度不够，地铁的运行时间也很短。 东京和香港地铁停运的时间都在午夜1点左右，而北京地铁在晚间11点左右就先后停运了，这对于“加班狗”来说实在不够友好。 事实上，即使短时间内地铁基础设施难以完善，北京也可以在提升通勤体验上做更好。 在北京地铁中难觅商业服务的身影，想买瓶水也要出站才能完成，在这点上，东京、上海更加以人为本，商业服务健全得多。 上海 地铁10号线水城路站内的便利店 不过即便是如此，地铁的乘坐体验也比公交好太多，不仅因为它快速，更因为它准时。北京公交车能够每天准点出现的少之又少。 相比之下，东京做得更好。东京的公交车司机会按照上下班等不同时间段，预先根据各车站的人流量估算出靠站时上下车的时间，然后通过调节行驶速度，把到站精准度控制在1分钟内。 此外，北京地铁上老人很少，但是早高峰的公交车上却到处都是老人。 65岁以上京籍老人免费乘坐公交车的制度，出发点很好，但也在一定程度上加剧了上班高峰时段的公交车拥挤。 如果北京能像上海一样，在工作日上班高峰时禁止使用老年卡，不仅更有利于实现错峰出行，也有助于减少老人在拥挤中发生的意外事故。公共交通主要用于解决远距离出行，自行车往往用于解决最后一公里出行，可惜在北京，自行车出行也没有那么让人顺心。 北京的马路那么宽，却并不是每一条都有自行车道；就算有，也常常要分一多半给机动车通行或停泊，就是在这窄窄的小巷中，还要和横冲直闯的快递车、外卖车抢路。 北京 中关村商圈 在丹麦、德国等地却是全然不同的场景，那里很多人骑自行车跨越十几二十公里通勤。 因为那里有着发达的自行车道路，甚至有专供自行车通行的高速公路，自行车可以安全迅速地在上面行驶，很可能比开车还快。 十几公里的自行车通勤若是发生在北京，一路上恐怕要经过几十个红绿灯，躲避十几个行人，还要担心不知道什么时候就杀出来的外卖小哥。 堵车，一半的锅要城市规划来背 刚来北京工作的南方妹子雨燕，对北京大街大路很不习惯。在她看来，北京的道路看起来恢弘大气，但实用性并不强。 虽然路很宽，但是道路密度却在一线城市中倒数第一，远低于深圳的平均水平。 2018年度《中国主要城市道路网密度监测报告》显示：以秦岭—淮河地理分界线为城市分类标准统计，南方城市道路网密度普遍高于北方城市。南方城市道路网密度平均值为6.62公里／平方公里，北方城市道路网密度平均值为5.07公里／平方公里。 北京这种修路风格，部分是大院文化导致的。在城市建设初期，大部分街区都是在大院（包括机关、院校、工厂）基础上形成的，办公住宿一体且门禁森严，必然占地面积很大，以大街区为主。 同时在房地产开发时，为了降低成本，地产商也喜欢大片拿地，开发成大型小区，这也是导致北京以大街区居多的原因。 然而，封闭的大街区必然导致路少、密度低，千军万马都要挤一条“独木桥”，两个地点的勾连方式单一。从A到B本来不远，却要绕一个大圈的事在北京极为常见。 北京 西直门立交桥 路宽，则使得跨越马路极为困难。汽车跨越马路，常常要多开三五公里，要是还有点拥堵，将白白浪费很多时间。 行人跨越马路也不容易，要么就是到人行天桥跑上跑下，要么就是在主路上设置N多行人红绿灯，汽车走走停停，一不小心就堵成大长龙。 街区规划得有问题，建筑设计得也有问题。对比各种国际化大都市，北京的楼盖得太低了。 在二环内的老城区，保持北京的性格和底蕴很有必要，但是在CBD，盖多高的楼都不过分，这方面只有国贸商圈做得还不错。 北京 国贸地区 土地高度利用不足，就只能提高占地面积，最后饼越摊越大，五环不行六环，六环不行再搞出一个大七环，通勤距离越拉越长。城市面积是够大了，但基础设施建设却没跟上来。 常有人说，大城市的好就是在那里可以享受到全国最优质的资源，美术展、演唱会、网红店应有尽有。 但是来了北京才知道，从五环外达到很多目的地的单程时间都会超过2个小时，这对好不容易才能在周末喘一口气的人来说太过于奢侈。 两年前的爆款文章《昌平名媛生活指南》就曾指出，每周末都会有大批的昌平名媛进五彩城“朝圣”，这是她们能够到达城市最南的位置，什么西单、三里屯、工体对她们来说只是存在于朋友圈中的ins风照片而已。 图片截自《昌平名媛生活指南》 全球最宜居城市？北京做得远远不够 最近，英国《经济学人》智库公布了2018年全球宜居城市，北京排名第75位，仅次于香港、苏州位列中国第三位，不知道别人怎么看，但是至少通勤族不会认同这一排名。 美国地理学家联合会研究表明通勤时间超过30分钟的人比其他人死得早，长距离通勤意味着锻炼和睡眠时间的减少，严重损害身心健康。 除了睡眠和运动，通勤也拖垮了北京青年的胃。为什么地铁口小吃摊屡禁不绝，为什么对便利店依赖度那么高，为什么外卖在北上广如此发达，很大程度都在于通勤占用了上班族大量的做饭时间，甚至吃饭时间。 身体的痛苦必然造成精神上的折磨。瑞典于默奥大学研究发现，长距离通勤会让离婚率上升40%，很大程度上是精神暴躁导致了无谓的家庭冲突。 可见，通勤对人的损害不仅发生在路上的那几个小时中。想要民众不再认为北京上榜全球最宜居城市是个冷笑话，北京还有许多路要走。 本文使用 Python 实现网络爬虫爬取数据…代码如下：crawl.py123456789101112# -*- coding: utf-8 -*-import urllibfrom bs4 import BeautifulSoupurl = "http://apis.yoobingo.com/v2/periphery/selectInformationInfo?device=0&amp;infoId=1512&amp;packageName=com.dmubiao.xgdk&amp;sign=893EC97E22DEF31BD965CAAADF0D9962"soup = BeautifulSoup(urllib.request.urlopen(url), 'html.parser')arr_p = soup.select('p')for x in arr_p: print(x.text) 原文地址点击跳转因阅读颇有感触故转载…本文转载自【习惯打卡】App 如有侵权请联系本人删除！]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“是贫穷限制了人的思维”，这句话你现在还信吗？]]></title>
    <url>%2F10-09-24%2F</url>
    <content type="text"><![CDATA[曾经看电影《风雨哈佛路》时，我一度很感动：主人公母亲去世，父亲不对她负责，明知生活的艰苦，她依然选择了读书；明明了解人性的黑暗，她但仍然用善良作为做人的标准。没有人可以和生活讨价还价，只要活着，就一定要努力。对穷人家的孩子来说尤其如此，不要因为穷，就不敢做梦。 15年前，我本科毕业时，因为喜爱写作，系里领导找到我，说如果有留校的意愿，他能给我争取一个名额，前提是要向学校交一笔3万元的保证金（当时只有研究生才有留校资格，我是本科生，但这笔钱将来会退还）。 那时，我半年的学费是1200元，一个月的生活费是100多元，一笔稿费不过15元。 所以，3万元对于我来说，犹如天文数字。 我想到父母面朝黄土背朝天地劳作，好不容易供我读完大学，如果我再因留校的问题，让他们去求爷爷告奶奶地借3万块钱，怎么想都觉得于心不忍。 我压根儿没和父母商量，辗转反侧地想了两天后，就对系领导说：「我不想留校，我要参加工作。」 后来，通过各种努力留校的同学，有的读研读博后成为本校的青年才俊，有的跳槽后应聘到其他高校谋职做事。 而回到地级市报社当记者的我，在纸媒衰落的当下不得不另谋出路。 多年后，当3万块钱对我来说不再是难题，当我终于接纳过去向父母袒露自己，才有勇气给他们提起这桩事。 「富人思来年，穷人顾眼前。」父亲眼角红红地对我说， 「穷人家孩子共同的病，是容易陷入愧疚和自责中，进而把父母处境看得太重。其实，当年，如果你对家人说了这事儿，我们就是砸锅卖铁、卖粮卖屋，也会给你想办法。因为这不是随便一个学生都能有的机会。」 原来，穷人家孩子最容易犯的错，就是因为穷，所以看得不够远，总怕自己给家人添乱，于是主动拒绝外援。 他忘记了，很多时候，解决问题的办法，其实大于想象中的困难。 14年前，我上班第二年，单位组织集体考驾照，每位员工只需要缴800元，就可以到指定驾校学习，5年之内只要考试过关，就能拿到驾照。 当时，同事们引以自豪的手机是诺基亚和摩托罗拉，单位院里停的最好的私家车是桑塔纳2000和老款两厢雪铁龙。 我站在三楼的采编室里，想到自己一个月不足千元的基本工资，想到眼下四处租房、下把面条都要数着下几根才合适的单身生活，感觉苦日子怎么望都望不到头。 我想，十年内能在这座城市买套房子，对于我来说都是件非常非常吃力的事儿，哪还有闲钱去买车？ 所以，考驾照根本没有必要，就压根儿没去报名。 后来，报名的同事都拿到了驾照，并陆续买了价位不一的私家车。 再后来，短短几年过去，考一个驾照要好几千块，王牌手机沦为落伍者被赶出市场，报社大院里的停车位上开始出现奥迪。 曾觉得生活无望的我，竟然也过上有房有车的婚姻生活。 那一刻，我才渐渐体悟：贫穷之所以会限制了自己的想象力，那是因为对于一个贫穷的年轻人来说，压根儿就不敢有想象力。 他总害怕绝望会代替希冀，所以不敢做梦； 他总害怕失败击倒成功，所以不敢出征。 他忘记了，自己还年轻，而努力和变化，会让一切皆有可能。 我之所以写上面两件亲身经历，是因为昨天下午，有位年轻读者给我留言。 她说自己参加工作刚满两年，现在一个月也就八九千块，扣除房租水电和生活费，也剩不下太多钱。但所在单位前景不错，主管领导也很器重她，再干大半年月薪会涨到一万多。 但现在，她老家的父亲突然患了重病，手术后卧床不起，只会越来越严重； 弟弟少不经事，还在读高中，考上大学也需要花不少钱； 母亲原本身体就差，父亲倒下后更是没了主见。 现在，她想放弃上海的工作，报考老家的公务员，或者托关系以人事代理的身份在市里找家单位，虽然一个月只有两三千，但离家近，能照顾病倒的爸爸，也能分担无助的妈妈。 我能理解这个女孩的处境和心情，但我还是对她说： 那些回到小地方的人，都很难再去远方。而那些留在远方的人，都很少后悔没回小地方。 对于穷人家的孩子来说，有一种孝顺，是强大你自己。 因为咱家穷，所以你更不能因为眼前的困难，而放弃占领的高地，你在尽己所能给予家人的同时，最重要的是拼命奔跑成为更好的自己。 只有这样，明天的你，才会成为自己和家人的希冀。 前两天，看见两则悲伤的新闻： 一个是，5月10日，45岁的南阳新野网约车女司机陈女士在襄阳跳桥自杀身亡。造就这桩悲剧的原因，是前一天，陈女士在襄阳火车站附近拉客时，被执法人员扣下车辆，并处罚2万元。事发当天，陈女士前去索要车辆被拒，感到生活无望，就选择纵身一跳。 另一个是，4月30日，22岁的湖州男青年小殷开车时撞倒一位骑电动车的老人，老人腿部骨折，小殷因自觉无力支付数万元的医疗费，索性选择上吊自杀。 不管输赢，都不要轻生。活下来，才有机会赢得公平。 不管成败，都不要自我伤害。挺下去，才有可能获得新生。 虽然，对于穷人来说，钱有时比命金贵多了，但如果没有了命，穷了这么多年的你怎么可能还有机会挣到钱？ 总害怕自己能力不足，耽误了家人的幸福，是很多穷人的软肋。 但纵身一跳或双眼一闭的你，怎么就忘记了： 一家人平安和睦，才是穷人家最宝贵的财富。 穷人家的孩子： 不要因为穷，就看不见身上的光。 穷不是你的错，不夸大困难，别逃避问题。 如果有机会搏一次，那就去试一试，当你的光芒照亮余生，你也有机会跳出固有的阶层。 不要因为穷，就屏蔽未来的无限可能。 一时的穷不可怕，可怕的是一生都跳不出穷人思维。 你只有跳出阴暗潮湿的井底，才发现广阔的天地其实一直都花红灯明。 不要因为穷，就潦草结束此生。 正是因为咱家穷，所以你更要撑得久一些。 只有你活成一棵不怕风雪的树，你的后代才有机会在前方开出芳香扑鼻的花。 不要因为穷，就把家人的想法看得太重。 最好的孩子，是懂得自我努力，然后带动一个家风生水起。 你只有活成渴望的模样，才有能力带领家人走出贫困的冰霜。 最后，我想给所有正遭遇贫穷、正经历不公的人，写这么一段话： 如果能有依靠谁愿忍受穷困潦倒既然无人可靠那就学会含泪奔跑 如果不幸摔倒拍拍身上的灰对自己笑一笑 你要的明天就在下一站拐角 作者介绍：刘娜，混迹媒体圈十余载，发表文字量百万字，能写亲情乡愁故事，也会写教育职场热点。微信公众号：闲时花开（ID:xsha369）。本文配图 / 《风雨哈佛路》 本文使用 Python 实现网络爬虫爬取数据…代码如下：crawl.py123456789101112# -*- coding: utf-8 -*-import urllibfrom bs4 import BeautifulSoupurl = "http://apis.yoobingo.com/v2/periphery/selectInformationInfo?device=0&amp;infoId=575&amp;packageName=com.dmubiao.xgdk&amp;sign=F1AE757A2DB66B0F4796727156DD5D1C"soup = BeautifulSoup(urllib.request.urlopen(url), 'html.parser')arr_p = soup.select('p')for x in arr_p: print(x.text) 原文地址点击跳转因阅读颇有感触故转载…本文转载自【习惯打卡】App 如有侵权请联系本人删除！]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缺一次钱，你就懂了]]></title>
    <url>%2F18-09-20%2F</url>
    <content type="text"><![CDATA[文章来源十点读书看到一个问题：“这世界上缺什么东西最可怕？” 底下最高赞的答案是这么说的：“这世上最可怕的不是缺爱，也不是缺心眼，而是缺钱。” 有一次和朋友阿伟吃饭的时候，聊到了一个话题：“经历什么事情，最容易看清一个人？” 阿伟愣了一些，然后笑着跟我说了他曾经历过的事： 我20岁走出社会，什么都不懂，只想着交朋友，那时候我认为朋友越多也就证明我混得越好。 在我21岁的时候，父母赞助我30万创业。那时候我一堆朋友，每天最少都有不少于20个朋友来我公司找我玩，并且都对我挺尊重的。 那时候的我很害怕孤独。 大家都知道我有钱，只要有朋友没钱，不管关系好不好，只要找到我，我绝对会借，凡是来找我帮忙的，我能帮到的都帮，帮不到的也帮，毕竟都是朋友。 俗话说得好，在家靠父母，出门靠朋友，不是吗？ 后来，开公司还没两年时间，我的身体垮了，生了一场大病住院，那会儿公司也碰上了一些问题，资金周转困难。 我住院第5天，我的助理打电话跟我说，公司撑不下去了，我实在没办法了，我打电话给那些借了我钱的朋友，希望他们能够还点钱，帮我渡过眼前的难关。 没想到打完电话，我就被拉黑了。 找了平时一起玩的朋友，想着借点钱扛一下，结果一个个都说没钱，帮不了你，你自己看着办吧。 这就算了，还有更过分的，你一定没想到，还有人在那个时候拿着一份借贷文件来医院找我，跟我说只要我签了那份文件，所有钱的问题都不是问题。 只要我签了，钱确实不是问题，只不过代价却是把我的房子和公司给他们。 当你没钱落魄的时候，最容易看透人心。 感情这东西，谁真谁假，缺一次钱，你就懂了。 有句很现实的话是这么说的：“穷在闹市无人问，富在深山有远亲。” 现在的我，不怕孤独，只怕没钱。 曾经有个读者在后台发私信问我：钱有多重要？ 那时候，我刚好因为感冒发烧去了医院，从医院打完针出来，看到这条私信，一时之间不知该如何回答。 那天看病我排号排了很久，好不容易轮到我，走进去，却发现还有个四五十岁的阿姨，抱着一个小朋友坐在旁边的凳子上量体温。 医生大概地了解了一下我的情况，然后给了我个体温计，让我到旁边坐着量一下体温，位置让给旁边的那个小朋友。 医生看了一下小朋友的症状，皱着眉头写了个单子给阿姨，让她先去前台缴费，然后带小朋友去验血顺便做一些检查，再回来继续看看。 然后让阿姨可以走了，让我过去坐着。 可是阿姨接过单子以后，就在旁边转悠着，也没走。 医生就问了一下：“你还有什么不懂的事吗？” 阿姨小声地问了一句：“医生，我们做这个检查要花多少钱啊？” 医生大概地说了一下，要五百多块钱。 阿姨皱了一下眉头，走到医生旁边，很不好意思地说：“医生，能不能通融一下，收费便宜一点，或者这个检查我孩子能不能不做了……你给开一点药吃吃看？” 医生说：“阿姨我理解你的心情，可能你是觉得做检查很没必要，但是你孩子这个病情必须得做个检查，才能够对症下药，我也才能够给他开药，这个钱没办法省的。” 阿姨叹了口气，对医生说道：“可是我们没那么多钱啊……” 接着很无奈地走了出去，也不知道有没有带孩子去做检查。 后来我去缴费的时候，又碰到了这位阿姨，抱着孩子坐在缴费大厅的凳子上，时不时看一眼医生开的单子，接着又看了看孩子。 可能是在想，究竟是花钱保孩子健康，还是不管了，就让孩子病着。 或许在看到这里的时候，有人会问我：不就几百块钱，至于让人这么为难吗？ 我只能说，缺一次钱，你就懂了。 钱重不重要并不在于你，而在于你什么时候需要用到。 需要拿钱救命的时候你没有，那这些钱就比你命还重要。 不知道你们有没有想过这几个问题： 第一，父母生大病的时候，你能不能拿出足够的钱让他们治疗？ 第二，孩子要上学受教育的时候，你是否能够让孩子去上好的学校？ 第三，爱人想要一个属于你们自己的房子时，你能否爽快无任何压力地答应她？ 第四，自己面临失业，或者创业失败，没有收入来源时，你有没有面对风险的能力？ 你有足够多的钱，就能够在父母生病的时候，可以底气十足地跟治疗他们的医生说：“放心吧，用最好的药，我有钱。” 可以在孩子要上学的时候，可以不要愁孩子能否受到好的教育，不用为付不起学费而头疼。 可以在爱人想要买任何东西时，毫不犹豫地跟她说：“买啊！喜欢就买，钱够。” 可以让你自己每时每刻都有着安全感，就算是因为特殊原因，让你没有收入来源时，你也不用慌慌张张。 有钱，意味着能够拥有更多的选择权，你可以选择做什么，而不是只能做什么。 但是，倘若你在遇到这些问题时，恰好没钱会是怎么样的一种结果？ 在父母生病住院时，没钱就意味着得不到更好的治疗，甚至明明可以治疗的病情，到最后却因为没钱而放弃了，只能无力地看着父母受到病魔的折磨，却不能改变什么。 在孩子要上学时，没钱就意味着你只能够将他送到那种廉价的幼儿园，去凑合凑合着过，根本顾不上他在里面是否能够受到好的教育。 在爱人想要买一些礼物，甚至想要买一些家具时，没钱就意味着你只能很无奈地跟她说：“不买了吧，我们没钱啊，钱要省点花。” 在自己失业，丢了工作时，没钱就意味你很可能会感到没有安全感，迷茫，焦虑，会觉得生活没法过了。 没钱，在很多时候就意味着四个字：无能为力。 或许有人会说，你这说得也太现实了吧？ 但我想告诉你，这从来就不是说说，这就是现实。 很多事情，等你缺一次钱，你就懂了。 关于钱，王尔德曾说过一句我很喜欢的话：“在我年轻的时候，曾以为金钱是世界上最重要的东西。现在我老了，才知道的确如此。” 买得起自己喜欢的东西，去得了自己想去的地方，做得到自己想做的事情，能够在这个世界拥有选择的权利。 在这个世界或许没有人能够靠得住，但你凭自己赚的钱靠得住，能够给你最大的安全感。 努力赚钱是为了什么？是为了在某一天需要急用到钱的时候，能够乐观地说：“有钱真好啊。”而不是无奈地说：“有钱，就好了。” 愿你的余生，不必因为钱而感到为难。 本文使用 Python 实现网络爬虫爬取数据…代码如下：crawl.py12345678910111213# -*- coding: utf-8 -*-import urllibfrom bs4 import BeautifulSoup# 要爬取的urlurl = "http://apis.yoobingo.com/v2/periphery/selectInformationInfo?device=0&amp;infoId=1474&amp;packageName=com.dmubiao.xgdk&amp;sign=3B0266912858E9B98DE274B16576A6C1"soup = BeautifulSoup(urllib.request.urlopen(url), 'html.parser')arr_p = soup.select('p')html_text = ''.join(map(str, arr_p))print(html_text) 原文地址点击跳转因阅读颇有感触故转载…本文转载自【习惯打卡】App 如有侵权请联系本人删除！]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django-编写前后分离开发接口]]></title>
    <url>%2FDjango-%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[上一篇已经说了django的跨域问题新建一个应用interfa，首先设置Django允许跨域。interfa/ views.py12345678from django.http import JsonResponsedef interfac(request): data = [ &#123;'name': 'mrceel', 'age': '20'&#125;, &#123;'name': '二傻', 'age': '19'&#125; ] return JsonResponse(data, safe=False) interfa/ 新建 urls.pyurls.py123456from django.urls import pathfrom . import viewsurlpatterns = [ path('', views.interfac, name='interfac')] 记得在项目目录下配置url/ urls.py12345678from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path('admin/', admin.site.urls), # 添加 path('interfa/', include('interfa.urls'))] 前端页面 index.html1234567891011...&lt;script&gt; $.ajax( url: 'http://localhost:8000/interfa/', Type: 'GET', success: function(data)&#123; console.log(data) &#125; )&lt;/script&gt;... 自此你已经完成了一个简单的接口文件…]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-Django解决跨域的问题]]></title>
    <url>%2FDjango-%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[跨域的问题是在前后段分离开发时….安装django-cors-headers 1pip3 install django-cors-headers 在项目目录里面的settings.py添加下面的代码1234567891011121314151617181920212223242526272829303132333435363738394041INSTALLED_APPS = [ ... 'corsheaders'， ] MIDDLEWARE_CLASSES = ( ... 'corsheaders.middleware.CorsMiddleware', 'django.middleware.common.CommonMiddleware', # 注意顺序 ...)#跨域增加忽略CORS_ALLOW_CREDENTIALS = TrueCORS_ORIGIN_ALLOW_ALL = TrueCORS_ORIGIN_WHITELIST = ( '*')# 设置允许请求方式CORS_ALLOW_METHODS = ( 'DELETE', 'GET', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'VIEW',)CORS_ALLOW_HEADERS = ( 'XMLHttpRequest', 'X_FILENAME', 'accept-encoding', 'authorization', 'content-type', 'dnt', 'origin', 'user-agent', 'x-csrftoken', 'x-requested-with', 'Pragma',) 一定要注意 tab 不要和 空格 混用!!!使用JSONP也是可以进行跨域请求的。。。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-Django框架快速入门]]></title>
    <url>%2FDjango-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装Django12345pip3 install django# 查看版本号等python -m django --version 创建项目1django-admin startproject mysite 回生成以下目录1234567mysite/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py 这些目录和文件的用处是： 最外层的:file: mysite/ 根目录只是你项目的容器， Django 不关心它的名字，你可以将它重命名为任何你喜欢的名字。 manage.py: 一个让你用各种方式管理 Django 项目的命令行工具。 里面一层的 mysite/ 目录包含你的项目，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名。 (比如 mysite.urls). mysite/__init__.py：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。如果你是 Python 初学者，阅读官方文档中的 更多关于包的知识。 mysite/settings.py：Django 项目的配置文件。 mysite/urls.py：Django 项目的 URL 声明，就像你网站的“目录”。 mysite/wsgi.py：作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。 开启服务123456789python manage.py runserver# 默认使用的是8000端口# 如果想要更换端口增加一个参数即可python manage.py runserver 8080# 如果你想要修改服务器监听的IP，在端口之前输入新的。python manage.py runserver 0:8000 新建一个应用(polls)123456789101112python manage.py startapp polls# 结构如下polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py 在polls/目录下 views.py 文件中1234from django.http import HttpResponsedef index(request): return HttpResponse('hello 丽丽') 在polls/目录下新建一个 urls.py 文件 用于配置这个应用的url123456789101112131415161718192021222324252627from django.http import pathfrom . import viewsurlpatterns = [ path('', views.index, name='index')]# 这里的views指的是views.py views.index 会调用 views.py里面的index函数''' path() 具有四个参数，两个必须参数：route 和 view，两个可选参数：kwargs 和 name。path() 参数： routeroute 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。这些准则不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 https://www.example.com/myapp/ 时，它会尝试匹配 myapp/ 。处理请求 https://www.example.com/myapp/?page=3 时，也只会尝试匹配 myapp/。path() 参数： view当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。path() 参数： kwargs任意个关键字参数可以作为一个字典传递给目标视图函数。path() 参数： name为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有用的特性允许你只改一个文件就能全局地修改某个 URL 模式。''' 下一步是要在根 URLconf 文件中指定我们创建的 polls.urls 模块。在 mysite/urls.py 文件的 urlpatterns 列表里插入一个 include()，如下：mysite/urls.py1234567891011from django.contrib import adminfrom django.urls import include, pathurlpatterns = [ path('polls/', include('polls.urls')), path('admin/', admin.site.urls),]# include() 是一个url正则匹配 例如： localhost：8000/polls/vue/# 这里他会匹配到第一条path 它会截断与此项匹配的 URL 的部分，# 并将剩余的字符串发送到include里面的polls.urls去处理# 第一个参数 是指 访问的url 例如： localhost：8000/polls/vue/ 这时候重启服务访问：localhost：8000/polls/成功的话可以看到 hello 丽丽 默认开启的某些应用需要至少一个数据表，所以，在使用他们之前需要在数据库中创建一些表。请执行以下命令：使用mysql时 settings.py的配置12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'test', 'USER': 'test', 'PASSWORD': 'test', 'HOST': 'localhost', 'PORT': '3306', &#125;&#125; 12345678910python manage.py migrate #创建表结构执行这里的时候可能会报错 django.db.utils.OperationalError: (1049, "Unknown database 'local'")这时候可以进入数据库交互式命令行中使用 "CREATE DATABASE database_name;" 然后在执行python manage.py migrate #创建表结构python manage.py makemigrations myapp #告诉django，myapp中的表结构有更新模型的迁移数据，它被储存在 polls/migrations/0001_initial.py 里。python manage.py migrate myapp #执行myapp中的表结构到mysql中在数据库里创建新定义的模型的数据表： polls/model.py1234567891011from django.db import modelsclass Question(models.Model): question_text = models.CharField(max_length=200) #varchar pub_date = models.DateTimeField('date published') #datetimeclass Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) #外键，关联其它模型，创建关联索引 choice_text = models.CharField(max_length=200) #varchar votes = models.IntegerField(default=0) #int 以上的类名代表了数据库表名，且继承了models.Model，类里面的字段代表数据表中的字段(name)，数据类型则由CharField（相当于varchar）、DateField（相当于datetime）， max_length 参数限定长度。 尽管我们没有在models给表设置主键，但是Django会自动添加一个id作为主键。 我们需要在配置类 INSTALLED_APPS 中添加设置。因为 PollsConfig 类写在文件 polls/apps.py 中，所以它的点式路径是 ‘polls.apps.PollsConfig’。在文件 mysite/settings.py 中 INSTALLED_APPS 子项添加点式路径后，它看起来像这样mysite/settings.py123456789INSTALLED_APPS = [ 'polls.apps.PollsConfig', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',] render() 「载入模板，填充上下文，再返回由它生成的 HttpResponse 对象」是一个非常常用的操作流程。 官网例子：123456789from django.shortcuts import renderfrom .models import Questiondef index(request): latest_question_list = Question.objects.order_by('-pub_date')[:5] context = &#123;'latest_question_list': latest_question_list&#125; return render(request, 'polls/index.html', context)]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQLClient 安装以及使用]]></title>
    <url>%2FPython-mysqlclient%2F</url>
    <content type="text"><![CDATA[安装MySQLClient pip3安装是会报错所以到下面链接安装相应的版本。例如 python3.6 就下载cp36https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysqlclient下载完成以后直接进入文件目录pip3 install &lt;文件名&gt;进行安装即可~ MySQLClient 的使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/env python3# -*- coding: utf-8 -*-import MySQLdb# 链接数据库con = MySQLdb.connect( host="localhost", port="3306", user="root", passwd="******", db="python_test" )# 获取游标cur = con.cursor()# 添加一条数据cur.execute('insert into test values(34, "timo", "12year", 22)')# 删除一条数据cur.execute('delete from test where id="34"')# 修改数据cur.execute('update test set id="33" where id="32')# 查询 返回 1 or 0print(cur.execute('select * from test where id= "31" '))#一次插入多条记录sqli="insert into test values(%s,%s,%s,%s)"cur.executemany(sqli,[ ('3','Tom','1 year 1 class','6'), ('3','Jack','2 year 1 class','7'), ('3','Yaheng','2 year 2 class','7'), ])#cur.close() 关闭游标cur.close()#conn.commit()方法在提交事物，在向数据库插入一条数据时必须要有这个方法，否则数据不会被真正的插入conn.commit()#conn.close()关闭数据库连接conn.close()# executemany()方法可以一次插入多条值，执行单挑sql语句,但是重复执行参数列表里的参数,返回值为受影响的行数。 fetchone()12345678910111213&gt;&gt;&gt; import MySQLdb&gt;&gt;&gt; conn = MySQLdb.connect(host=&apos;localhost&apos;,port = 3306,user=&apos;root&apos;, passwd=&apos;123456&apos;, db =&apos;test&apos;,)&gt;&gt;&gt; cur = conn.cursor()&gt;&gt;&gt; cur.execute(&quot;select * from student&quot;)5L&gt;&gt;&gt; cur.fetchone()(1L, &apos;Alen&apos;, &apos;1 year 2 class&apos;, &apos;6&apos;)&gt;&gt;&gt; cur.fetchone()(3L, &apos;Huhu&apos;, &apos;2 year 1 class&apos;, &apos;7&apos;)&gt;&gt;&gt; cur.fetchone()(3L, &apos;Tom&apos;, &apos;1 year 1 class&apos;, &apos;6&apos;)...&gt;&gt;&gt;cur.scroll(0,&apos;absolute&apos;) fetchone()方法可以帮助我们获得表中的数据，可是每次执行cur.fetchone() 获得的数据都不一样，换句话说每执行一次，游标会从表中的第一条数据移动到下一条数据的位置，所以，再次执行的时候得到的是第二条数据。 fetchmany()12345678#获得表中有多少条数据aa=cur.execute(&quot;select * from student&quot;)print aa#打印表中的多少数据info = cur.fetchmany(aa)for ii in info: print ii fetchmany()方法可以获得多条数据，但需要指定数据的条数，通过一个for循环就可以把多条数据打印出来。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-urllib模块的使用总结]]></title>
    <url>%2FPython-%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[urllib模块可以非常方便地抓取URL内容，然后返回内容，1. urllib.urlopen(url[,data[,proxies]])urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)描述：第一个参数可以传递URL之外，我们还可以传递其它的内容，比如 data （附加参数）， timeout （超时时间）等等。data 参数是可选的，如果要添加 data ，它要是字节流编码格式的内容，即 bytes 类型，通过 bytes() 函数可以进行转化，另外如果你传递了这个 data 参数，它的请求方式就不再是 GET 方式请求，而是 POST 。123456789urlopen返回对象提供方法： read() , readline() ,readlines() , fileno() , close() ：这些方法的使用方式与文件对象完全一样 info()：返回一个httplib.HTTPMessage对象，表示远程服务器返回的头信息 getcode()：返回Http状态码。如果是http请求，200请求成功完成;404网址未找到 geturl()：返回请求的url 2.urllib.urlretrieve(url[,filename[,reporthook[,data]]])描述：将url定位到的html文件下载到你本地的硬盘中。如果不指定filename，则会存为临时文件。1234567from urllib import requestrequest.urlretrieve(urlPath, './%s.jpg' % fileName)urlPath: 网页地址 / 图片地址fileName: 储存地址 例如：'./python/img/xxx.html' 3.urllib.urlcleanup()描述：清除由于urllib.urlretrieve()所产生的缓存 4.urllib.urlencode(query)描述：将URL中的键值对以连接符&amp;划分,这里可以与urlopen结合以实现post方法和get方法POST方法1234567import urllibdata = urllib.parse.urlencode(&#123;'wd':'123456'&#125;).encode('utf-8')print(data) # b'wd=123456'html = urllib.request.urlopen("http://httpbin.org/post", data=data).read().decode('utf-8')print(html) http://httpbin.org/post这个地址可以用来测试 POST 请求，它可以输出请求和响应信息，其中就包含我们传递的 data 参数。 GET方法12345import urllib.request response = urllib.request.urlopen("https://www.baidu.com")print(response.read().decode("utf-8")) 5.urllib.request.Request的使用1class urllib.request.Request(url, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False, method=None) url 参数是请求链接，这个是必传参数，其他的都是可选参数。 data 参数如果要传必须传 bytes （字节流）类型的，如果是一个字典，可以先用 urllib.parse.urlencode() 编码。 headers 参数是一个字典，你可以在构造 Request 时通过 headers 参数传递，也可以通过调用 Request 对象的 add_header() 方法来添加请求头。请求头最常用的用法就是通过修改 User-Agent 来伪装浏览器，默认的 User-Agent 是 Python-urllib ，你可以通过修改它来伪装浏览器，比如要伪装火狐浏览器，你可以把它设置为 Mozilla/5.0 (X11; U; Linux i686)Gecko/20071127 Firefox/2.0.0.11 origin_req_host 指的是请求方的 host 名称或者 IP 地址。 unverifiable 指的是这个请求是否是无法验证的，默认是 False 。意思就是说用户没有足够权限来选择接收这个请求的结果。例如我们请求一个HTML文档中的图片，但是我们没有自动抓取图像的权限，这时 unverifiable 的值就是 True 。 method 是一个字符串，它用来指示请求使用的方法，比如 GET ， POST ， PUT 等等。 1234567import urllib request =urllib.request.Request("http://www.baidu.com")response = urllib.request.urlopen(request)print(response.read().decode("utf-8")) 我们依然是用 urlopen() 方法来发送这个请求，只不过这次 urlopen() 方法的参数不再是一个URL，而是一个 Request ，通过构造这个这个数据结构，一方面我们可以将请求独立成一个对象，另一方面可配置参数更加丰富和灵活。 实例：123456789101112131415161718from urllib import request,parseurl = "http://httpbin.org/post"headers = &#123; #伪装一个火狐浏览器 "User-Agent":'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)', "host":'httpbin.org'&#125;dict = &#123; "name":"Germey"&#125;data = parse.urlencode(dict).encode("utf8")# data = bytes(parse.urlencode(dict),encoding="utf8")req = request.Request(url=url,data=data,headers=headers,method="POST")response = request.urlopen(req)print(response.read().decode("utf-8")) 在这里我们通过四个参数构造了一个 Request ， url 即请求链接，在 headers 中指定了 User-Agent 和 Host ，传递的参数 data 用了 urlencode() 和 bytes() 方法来转成字节流，另外指定了请求方式为 POST 。 结果是：123456789101112131415161718192021&#123; "args": &#123;&#125;, "data": "", "files": &#123;&#125;, "form": &#123; "name": "Germey" &#125;, "headers": &#123; "Accept-Encoding": "identity", "Connection": "close", "Content-Length": "11", "Content-Type": "application/x-www-form-urlencoded", "Host": "httpbin.org", "User-Agent": "Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)" &#125;, "json": null, "origin": "125.46.249.76", "url": "http://httpbin.org/post"&#125;[Finished in 1.3s] 6.高级特性接下来就需要更强大的工具 Handler 登场了。 简而言之你可以把它理解为各种处理器，有专门处理登录验证的，有处理 Cookies 的，有处理代理设置的，利用它们我们几乎可以做到任何 HTTP 请求中所有的事情。 首先介绍下 urllib.request.BaseHandler ，它是所有其他 Handler 的父类，它提供了最基本的 Handler 的方法，例如 default_open() 、 protocol_request() 等。接下来就有各种 Handler 类继承这个 BaseHandler ，列举如下： HTTPDefaultErrorHandler 用于处理HTTP响应错误，错误都会抛出 HTTPError 类型的异常。 HTTPRedirectHandler 用于处理重定向。 HTTPCookieProcessor 用于处理 Cookie 。 ProxyHandler 用于设置代理，默认代理为空。 HTTPPasswordMgr 用于管理密码，它维护了用户名密码的表。 HTTPBasicAuthHandler 用于管理认证，如果一个链接打开时需要认证，那么可以用它来解决认证问题。 另外还有其他的 Handler ，可以参考官方文档。1https://docs.python.org/3/library/urllib.request.html#urllib.request.BaseHandler 它们怎么来使用，不用着急，下面会有实例为你演示。另外一个比较重要的就是 OpenerDirector ，我们可以称之为 Opener ，我们之前用过 urllib.request.urlopen() 这个方法，实际上它就是一个 Opener 。那么为什么要引入 Opener 呢？因为我们需要实现更高级的功能，之前我们使用的 Request 、 urlopen() 相当于类库为你封装好了极其常用的请求方法，利用它们两个我们就可以完成基本的请求，但是现在不一样了，我们需要实现更高级的功能，所以我们需要深入一层，使用更上层的实例来完成我们的操作。所以，在这里我们就用到了比调用 urlopen() 的对象的更普遍的对象，也就是 Opener 。 Opener 可以使用 open() 方法，返回的类型和 urlopen() 如出一辙。那么它和 Handler 有什么关系？简而言之，就是利用 Handler 来构建 Opener 。认证我们先用一个实例来感受一下123456789import urllib.requestauth_handler = urllib.request.HTTPBasicAuthHandler()auth_handler.add_password(realm='PDQ Application', uri='https://mahler:8092/site-updates.py', user='klem', passwd='kadidd!ehopper')opener = urllib.request.build_opener(auth_handler)urllib.request.install_opener(opener)urllib.request.urlopen('http://www.example.com/login.html') 此处代码为实例代码，用于说明 Handler 和 Opener 的使用方法。在这里，首先实例化了一个 HTTPBasicAuthHandler 对象，然后利用 add_password() 添加进去用户名和密码，相当于建立了一个处理认证的处理器。接下来利用 urllib.request.build_opener() 方法来利用这个处理器构建一个 Opener ，那么这个 Opener 在发送请求的时候就具备了认证功能了。接下来利用 Opener 的 open() 方法打开链接，就可以完成认证了。 代理如果添加代理，可以这样做：12345678import urllib.requestproxy_handler = urllib.request.ProxyHandler(&#123;'http': 'http://218.202.111.10:80','https': 'https://180.250.163.34:8888'&#125;)opener = urllib.request.build_opener(proxy_handler)response = opener.open('https://www.baidu.com')print(response.read()) 此处代码为实例代码，用于说明代理的设置方法，代理可能已经失效。 在这里使用了 ProxyHandler ， ProxyHandler 的参数是一个字典，key是协议类型，比如 http 还是 https 等，value是代理链接，可以添加多个代理。然后利用 build_opener() 方法利用这个 Handler 构造一个 Opener ，然后发送请求即可。 7.Cookie设置1234567import http.cookiejar, urllib.requestcookie = http.cookiejar.CookieJar()handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')for item in cookie: print(item.name+"="+item.value) 运行结果：12345678BAIDUID=FA5D3EA91FC106883E2C63D56E7C667B:FG=1BIDUPSID=FA5D3EA91FC106883E2C63D56E7C667BH_PS_PSSID=PSTM=1535618742BDSVRTM=0BD_HOME=0delPer=0[Finished in 0.8s] 文章整理自https://blog.csdn.net/bo_mask/article/details/76067790]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openprxl]]></title>
    <url>%2Fpython-openpyxl%2F</url>
    <content type="text"><![CDATA[操作Excel文件建议使用openpyxl 兼容office2016打开excel文件，获取工作表123456789import openpyxlwb=openpyxl.load_workbook('ttt.xlsx') #打开excel文件print(wb.get_sheet_names()) #获取工作簿所有工作表名sheet=wb.get_sheet_by_name('Sheet1') #获取工作表print(sheet.title) sheet02=wb.get_active_sheet() #获取活动的工作表print(sheet02.title) 操作单元格1234567891011print(sheet['A1'].value) #获取单元格A1值print(sheet['A1'].column) #获取单元格列值print(sheet['A1'].row) #获取单元格行号print(sheet.cell(row=1,column=1).value) #获取单元格A1值，column与row依然可用for i in range(1,4,1): print(sheet.cell(row=i,column=1).value) #更加方便实用print(sheet.max_column) #获取最大列数print(sheet.max_row) #获取最大行数 读取excel文件123456789101112131415161718192021222324252627#读取excel文件 sheetname可为空def readwb(wbname,sheetname): wb=openpyxl.load_workbook(filename=wbname,read_only=True) if (sheetname==""): ws=wb.active else: ws=wb[sheetname] i=1 fields=[] data=[] for row in ws.rows: list=[] for cell in row: aa=str(cell.value) if (aa==""): aa="1" list.append(aa) if(i&lt;5): pass elif (i==5): fields=list else: data.append(list) i=i+1 data.sort(key=lambda x:x[0]) print (wbname +"-"+sheetname+"- 已成功读取") return fields,data 新建excel，并写入数据1234567891011121314151617181920212223242526#新建exceldef creatwb(wbname): wb=openpyxl.Workbook() wb.save(filename=wbname) print ("新建Excel："+wbname+"成功")# 写入excel文件中 date 数据， fields 表头def savetoexcel(data,fields,sheetname,wbname): print("写入excel：") wb=openpyxl.load_workbook(filename=wbname) sheet=wb.active sheet.title=sheetname field=1 for field in range(1,len(fields)+1): # 写入表头 _=sheet.cell(row=1,column=field,value=str(fields[field-1])) row1=1 col1=0 for row1 in range(2,len(data)+2): # 写入数据 for col1 in range(1,len(data[row1-2])+1): _=sheet.cell(row=row1,column=col1,value=str(data[row1-2][col1-1])) wb.save(filename=wbname) print("保存成功")]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeautifulSoup 的使用总结]]></title>
    <url>%2FBeautifulSoup%2F</url>
    <content type="text"><![CDATA[python中BeautifulSoup库的基础应用，网页数据挖掘的常用库之一。也就是说最主要的功能是从网页抓取数据。 对象划分解析以后全部html代码转变为4种类型：基本对象类型1、 Tag——标签，最基本的信息组织单元，分别用&lt;&gt;和&lt;/&gt;表明开头和结尾 1.1、标签Name属性——标签的名字，&lt;p&gt;...&lt;/p&gt;的名字是’p’,格式：&lt;tag&gt;.name 1.2、标签Attributes属性——标签的属性，字典形式组织，格式：&lt;tag&gt;.attrs 2、NavigableString——标签内非属性字符串，&lt;&gt;...&lt;/&gt;中的字符串，格式：&lt;tag&gt;.string3、Comment——标签内字符串的注释部分，一种特殊的Comment类型（尖括号叹号表示注释开始：&lt;!--This is a commet--&gt;）4、BeautifulSoup对象(整个html对象soup) 爬取网页源代码以及解析代码12345678910111213141516171819#coding:utf-8# BeautifulSoup抓取import urllib #python3中urllib整合了五大模块urllib.error、urllib.parse、urllib.request、urllib.response、urllib.robotparserimport refrom bs4 import BeautifulSoup# 获取网页源代码host = 'http://www.525heart.com/index/index/index.html'text = urllib.request.urlopen(host).read() #获取网页源代码，是字节数组#response=urllib.request.urlopen(host)#text = str(response.read(),encoding='utf-8') #read获取的是字节数组，可以翻译成字符串# 解析网页源代码soup = BeautifulSoup(text, 'html.parser') #前一个参数为要解析的文本，后一个参数为解析模型# bs4的HTML解析器：BeautifulSoup(mk,'html.parser')——条件：安装bs4库# lxml的HTML解析器：BeautifulSoup(mk,'lxml')——pip install lxml# lxml的XML解析器：BeautifulSoup(mk,'xml')——pip install lxml# html5lib的解析器：BeautifulSoup(mk,'html5lib')——pip install html5lib# print(soup.prettify()) #打印解析的内容 获取标签内容以及属性123456789101112131415161718192021print(soup.a) #第一个a标签print(soup.a.string) #第一个a标签的文本显示 无内容则返Noneprint(soup.a.get_text()) #获取标签内文本内容 无内容则返回空print(type(soup.a.string)) #查看第一个a标签的对象类型，类型可以能是bs4.element.xxx#标签获取for tag in soup('a'): #根据标签名获取标签# print tag.name #标签的名字# print tag.parent.name #标签的父标签的名字# print tag.parent.parent.name #标签的父标签的父标签名字# print tag.string #获得标签内非属性字符串（NavigableString ）innerText link = tag.attrs['href'] #标签的属性 link = tag['href'] #标签的属性 link = tag.get('href') #标签的属性 print(urllib.parse.urljoin(host,link)), #拼接网址中的连接变为绝对连接 print(tag.name), #标签的名称 print(tag.attrs), #属性 print(tag.string) #标签内的文本显示 print(tag.get_text()) #获取标签内文本内容 搜索12345678910111213141516171819202122232425262728293031323334353637print("============搜索============")# find_all( name , attrs , recursive , text , **kwargs ) #返回结果只包含一个元素的列表# find( name , attrs , recursive , text , **kwargs ) #直接返回结果print("============搜索-按标签搜索============")print(soup.find_all('a')[0]) #按字符串查询print(soup.find_all(re.compile("^a"))[0]) #按正则表达式查询print(soup.find_all(["a", "b"])[0]) #按列表查询print(soup.find_all(True)[1]) #查询所有元素，第一个元素就是html元素，就是整个全文def has_class_but_no_id(tag): return tag.has_attr('href') and not tag.has_attr('target') #返回 True才查询print(soup.find_all(has_class_but_no_id)) #按方法查询print("============搜索-按属性搜索============")print(soup.find_all(id='headerImg')) #按属性值查询,data-*不能查询print(soup.find_all(href=re.compile("#"))) #按属性值的正则表达式查询print(soup.find_all(href=re.compile(".*index\.html"), target='_blank')) #按属性值列表查询print(soup.find_all("a", class_="current")) #标签属性联合搜索，class 是 python 的关键词，所以加了_print(soup.find_all(attrs=&#123;"class": "current"&#125;)) #搜索包含指定属性值的元素print("============搜索-按文本搜索============")print(soup.find_all(text="首页")) #按文本搜素，接受的参数与按标签搜索一样print(soup.find_all("a", limit=2,recursive=False)) #以上所有搜索都可以用limit限定最大搜索到的数目，用recursive限定只搜索直接子节点print("============搜索-按css选择器名称搜索============")print(soup.select('title')) #按名称print(soup.select('.current')) #按类名print(soup.select('#headerImg')) #按idprint(soup.select('li .current')) #后代查询print(soup.select("head &gt; title")) #子标签查询print(soup.select('a[class="current"]')) #属性查询 遍历12345678910111213141516171819202122232425262728293031323334353637383940print("============节点遍历-向下遍历============")#find_parents() find_parent() #搜索当前节点的父辈节点#find_next_siblings() find_next_sibling() #搜索符合条件的后面的兄弟节点#find_previous_siblings() find_previous_sibling() #搜索符合条件的前面的兄弟节点#find_all_next() find_next() #对当前 tag 的之后的 tag 和字符串进行迭代#find_all_previous() 和 find_previous() #对当前节点前面的 tag 和字符串进行迭代#遍历（向下）# contents属性：直接子节点的列表，将&lt;tag&gt;所有儿子节点存入列表print(soup.head.contents[0])# children属性：子节点的迭代类型，与.contents类似，用于循环遍历儿子节点# descendants属性：后代节点的迭代类型，包含所有子孙节点，用于循环遍历for child in soup.body.children: #直接子节点列表,迭代类型，需要用循环方式，空格、换行也是子节点 print("body's child："+str(child.name))#for string in soup.strings: #遍历获取所有显示文本内容，soup.stripped_strings可以去除空格或换行# print(repr(string))#遍历（向上）# parent属性：节点的父标签# parents属性：节点先辈标签的迭代类型，用于循环遍历先辈节点print("============节点遍历-同胞遍历============")#遍历（平级）firstli=soup('li')[0] #等价于soup.liprint(firstli.next_sibling) #注意空格换行也是节点print(firstli.previous_sibling) #注意空格换行也是节点for sibling in firstli.next_siblings: #注意空格换行也是节点 print('next_siblings:',sibling)for sibling in firstli.previous_siblings: #注意空格换行也是节点 print('previous_siblings:'+str(sibling))#遍历（代码前后）#next_elements当前节点之后的所有节点#previous_elements当前节点之前的所有节点#next_element当前节点的下一个节点#previous_element当前节点的前一个节点 以上内容总结自：https://blog.csdn.net/luanpeng825485697/article/details/78378653]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy - 快速入门]]></title>
    <url>%2Fscrapy%2F</url>
    <content type="text"><![CDATA[Spider是用户编写用于从单个网站(或者一些网站)爬取数据的类。 创建项目1scrapy startproject &lt;your project-name&gt; 会创建一个类似以下的目录(例如名字叫tutorial)12345678910111213141516tutorial/ scrapy.cfg # deploy configuration file tutorial/ # project's Python module, you'll import your code from here __init__.py items.py # project items definition file middlewares.py # project middlewares file pipelines.py # project pipelines file settings.py # project settings file spiders/ # a directory where you'll later put your spiders __init__.py 我们的爬虫代码一般放在tutorial/spider/下例如：jimi.py123456789import scrapyfrom tutorial.items import JimiItemclass JimiSpider(scrapy.Spider): name = "jimi" start_urls = ["https://book.douban.com/author/4504814/"] def parse(self, response): pass 为了创建一个Spider，您必须继承 scrapy.Spider 类， 且定义以下三个属性:我们的Spider子类scrapy.Spider 并定义了一些属性和方法： name：识别爬虫。它在项目中必须是唯一的，也就是说，不能为不同的Spiders设置相同的名称。 start_requests()：必须返回Spider将开始爬行的可迭代请求（可以返回请求列表或编写生成器函数）。后续请求将从这些初始请求中连续生成。 parse()：将调用一个方法来处理为每个请求下载的响应。响应参数是TextResponse保存页面内容的实例，并具有处理它的其他有用方法。该parse()方法通常解析响应，将抽取的数据提取为dicts，并查找要遵循的新URL并Request从中创建新的request（）。 运行我们的文件：转到项目根目录，输入下面代码(这里的quotes就是quotes_spider.py文件里面的name值)1scrapy crawl quotes 提取数据 学习如何使用Scrapy提取数据的最佳方法是使用shell Scrapy shell尝试选择器。运行(url 需要带上引号)：1scrapy shell 'https://book.douban.com/author/4504814/' 你会看到类似的输出日志：12345678910111213141516171819202018-08-28 18:06:49 [scrapy.middleware] INFO: Enabled item pipelines:['tutorial.pipelines.TutorialPipeline']2018-08-28 18:06:49 [scrapy.extensions.telnet] DEBUG: Telnet console listening on 127.0.0.1:60232018-08-28 18:06:49 [scrapy.core.engine] INFO: Spider opened2018-08-28 18:06:50 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://book.douban.com/robots.txt&gt; (referer: None)2018-08-28 18:06:50 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://book.douban.com/author/4504814/&gt; (referer: None)[s] Available Scrapy objects:[s] scrapy scrapy module (contains scrapy.Request, scrapy.Selector, etc)[s] crawler &lt;scrapy.crawler.Crawler object at 0x000002363EE7BB70&gt;[s] item &#123;&#125;[s] request &lt;GET https://book.douban.com/author/4504814/&gt;[s] response &lt;200 https://book.douban.com/author/4504814/&gt;[s] settings &lt;scrapy.settings.Settings object at 0x00000236414B2A20&gt;[s] spider &lt;DefaultSpider 'default' at 0x236419cb198&gt;[s] Useful shortcuts:[s] fetch(url[, redirect=True]) Fetch URL and update local objects (by default, redirects are followed)[s] fetch(req) Fetch a scrapy.Request and update local objects[s] shelp() Shell help (print this help)[s] view(response) View response in a browserIn [1]: 此时可以测试提取数据的代码 例如：1In [1]:response.xpath('//div[@id="wrapper"]/div[@id="content"]/h1/text()').extract_first() 退出shell： ctrl + d jimi.py12345678910111213# -*- coding: utf-8 -*-import scrapyfrom tutorial.items import JimiItemclass JimiSpider(scrapy.Spider): name = "jimi" start_urls = ["https://book.douban.com/author/4504814/"] def parse(self, response): item = JimiItem() item["title"] = response.xpath('//div[@id="wrapper"]/div[@id="content"]/h1/text()').extract_first() item["describe"] = response.xpath('//div[@id="wrapper"]/div[@id="content"]/div/div[@class="article"]/div[@id="intro"]/div[@class="bd"]/text()').extract_first() yield item 上面文件引入了JimiItem，现在看下items.py文件。（items文件具体是做什么的我也不清楚…）items.py12345678910# -*- coding: utf-8 -*-import scrapyfrom scrapy import Field, Itemclass JimiItem(Item): title = Field() describe = Field() book_title = Field() book_link = Field() # 这里定义了4个 其实只用了前两个 接下来看下pipelines.py文件1234567891011# -*- coding: utf-8 -*-import jsonclass TutorialPipeline(object): def open_spider(self, spider): # 该方法在spider启用的时候调用 self.file = open('3.json', 'w') def process_item(self, item, spider): # 大概是在中间的时候调用... line = json.dumps(dict(item)) + "\n" self.file.write(line) return item def close_spider(self, spider): # 该方法在spider结束的时候调用 self.file.close() 还有就是要在settings.py文件中释放123ITEM_PIPELINES = &#123; 'tutorial.pipelines.TutorialPipeline': 300,&#125; 后面的数字“300”，是优先级，数字越小，越优先执行 总结 在终端中输入以下命令，查看scrapy有哪些命令语法1scrapy -h 生成spider创建spider。一般创建的spider名字是跟域名一样的，比如www.baidu.com，我们穿件的爬虫命令(个人感觉有点麻烦，还不如直接手动新建文件)1scrapy genspider baidu baidu.com 开始爬取1scrapy crawl &lt;spidername&gt; 结语： “这个框架我也没有感觉到特别的地方，接下来尝试不使用框架爬取数据。”]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda 安装以及使用]]></title>
    <url>%2FAnaconda%2F</url>
    <content type="text"><![CDATA[Anaconda安装包地址:https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/conda 的包管理：例如安装scipy1234567# 安装scipyconda install scipy# conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库） # 查看已经安装的packagesconda list# 最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包 conda的一些常用操作如下：12345678910111213141516171819# 查看当前环境下已安装的包conda list # 查看某个指定环境的已安装包conda list -n python34 # 查找package信息conda search numpy # 安装packageconda install -n python34 numpy# 如果不用-n指定环境名称，则被安装在当前活跃环境# 也可以通过-c指定通过某个channel安装 # 更新packageconda update -n python34 numpy # 删除packageconda remove -n python34 numpy 前面已经提到，conda将conda、python等都视为package，因此，完全可以使用conda来管理conda和python的版本，例如123456789# 更新conda，保持conda最新conda update conda # 更新anacondaconda update anaconda # 更新pythonconda update python# 假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本 补充：如果创建新的python环境，比如3.4，运行conda create -n python34 python=3.4之后，conda仅安装python 3.4相关的必须项，如python, pip等，如果希望该环境像默认环境那样，安装anaconda集合包，只需要：123456# 在当前环境下安装anaconda包集合conda install anaconda # 结合创建环境的命令，以上操作可以合并为conda create -n python34 python=3.4 anaconda# 也可以不用全部安装，根据需求安装自己需要的package即可 设置国内镜像 *如果需要安装很多packages，你会发现conda下载的速度经常很慢，因为Anaconda.org的服务器在国外。所幸的是，清华TUNA镜像源有Anaconda仓库的镜像，我们将其加入conda的配置即可：123456# 添加Anaconda的TUNA镜像conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/# TUNA的help中镜像地址加有引号，需要去掉 # 设置搜索时显示通道地址conda config --set show_channel_urls yes 执行完上述命令后，会生成~/.condarc(Linux/Mac)或C:UsersUSER_NAME.condarc文件，记录着我们对conda的配置，直接手动创建、编辑该文件是相同的效果。(如果是在清华镜像下载的安装包好像是不用配置这个，因为他会自动配置好) 在Anaconda Prompt中利用Anaconda创建一个python3.5的环境，环境名称为tensorflow ，输入下面命令：1conda create -n tensorflow python=3.5 假设我们需要安装Python 3.4，此时，我们需要做的操作如下：123456789101112131415161718# 创建一个名为python34的环境，指定Python版本是3.4（不用管是3.4.x，conda会为我们自动寻找3.4.x中的最新版本）conda create --name python34 python=3.4 # 安装好后，使用activate激活某个环境activate python34 # for Windowssource activate python34 # for Linux &amp; Mac# 激活后，会发现terminal输入的地方多了python34的字样，实际上，此时系统做的事情就是把默认2.7环境从PATH中去除，再把3.4对应的命令加入PATH # 此时，再次输入python --version# 可以得到`Python 3.4.5 :: Anaconda 4.1.1 (64-bit)`，即系统已经切换到了3.4的环境 # 如果想返回默认的python 2.7环境，运行deactivate # for Windows ()source deactivate python34 # for Linux &amp; Mac # 删除一个已有的环境conda remove --name python34 --all 本文整理于https://blog.csdn.net/accumulate_zhang/article/details/77371657]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-__name__]]></title>
    <url>%2FPython-__name__%2F</url>
    <content type="text"><![CDATA[name 是内置变量，用于表示当前模块的名字,如果一个模块被直接运行,其 name 值为 main。来个小栗子： module.py 文件 1234567891011121314#!/usr/bin/env python3# -*- coding: utf-8 -*-' a test module '__author__ = 'mrceel'def say(name): print('hello %s' %(name))print('当前文件的__name__是：', __name__)if __name__ == '__main__': say('world') 直接运行-&gt;输出位为123当前文件的__name__是： __main__hello world[Finished in 0.1s] 再来看下作为模块使用的时候 test-module.py 文件 12345import modulemodule.say('二丽') # 调用module 模块的say 函数print('当前文件的__name__是：', __name__) 直接运行-&gt;输出位为1234当前文件的__name__是： module # 这里是module.py 文件的输出hello 二丽 # 调用 module 模块的say 函数的输出当前文件的__name__是： __main__ # 当前文件输出[Finished in 0.3s] Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该module模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现统计文本当中单词的数量]]></title>
    <url>%2Fstatistics-word-number%2F</url>
    <content type="text"><![CDATA[Python实现统计文本当中单词的数量，1234567891011121314151617181920212223242526import refo = open('technology.txt', encoding='gb18030', errors='ignore')# 把文本变成单个的单词放到list里面def readFiles(file): arr = [] lines = file.readlines() for line in lines: # 本文中只有, ; . 三个符号所以直接匹配这三个 line = re.sub('[\n,;.]', '', line) line = line.strip() if line.strip() != '': arr.extend(line.split(' ')) return arrwordList = readFiles(fo)def statistics(arr): json = &#123;&#125;.fromkeys(arr) for i in json: json[i] = arr.count(i) jsn = [] for key, val in json.items(): if max(json.values()) == val: jsn.append((key, val)) return json, jsnprint(statistics(wordList))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-iamge模块]]></title>
    <url>%2FPython-iamge%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[from PIL import Image 引入 模块1、 打开(读取)图片img = Image.open(&#39;tu.png&#39;) 2、 显示(查看)图片img.show() 3、 保存图片img.save(&quot;save.gif&quot;,&quot;GIF&quot;)保存图像为gif格式 4、 创建新图片12Image.new(mode,size)Image.new(mode,size,color) 例如：newImg = Image.new(&quot;RGBA&quot;,(640,480),(0,255,0)) 5、 两张图片相加Image.blend(img1,img2,alpha)这里alpha表示img1和img2的比例参数 6、 点操作im.point(function)这个function接受一个参数，且对图片中的每一个点执行这个函数比如：out=im.point(lambdai:i*1.5)对每个点进行50%的加强 7、 查看图像信息im.format, im.size, im.mode 8、 图片裁剪12img.crop(box)box=(100,100,500,500) 设置要裁剪的区域region=img.crop(box)此时，region是一个新的图像对象。 9、 图像黏贴（合并）im.paste(region,box)粘贴box大小的region到原先的图片对象中。 10、 通道分离r,g,b=im.split()分割成三个通道，此时r,g,b分别为三个图像对象。 11、 通道合并im=Image.merge(&quot;RGB&quot;,(b,g,r))将b,r两个通道进行翻转。 12、 改变图像的大小out=img.resize((128,128))resize成128*128像素大小 13、 旋转图像out=img.rotate(45)逆时针旋转45度 有更方便的region = region.transpose(Image.ROTATE_180） 14、 图像转换out = im.transpose(Image.FLIP_LEFT_RIGHT)左右对换。 out = im.transpose(Image.FLIP_TOP_BOTTOM)上下对换 15、 图像类型转换im=im.convert(&quot;RGBA&quot;) 16、 获取某个像素位置的值im.getpixel((4,4)) 17、 写某个像素位置的值img.putpixel((4,4),(255,0,0)) 18、 创建画笔,用于在图片上生成内容draw1 = ImageDraw.Draw(img1, mode=&quot;RGB&quot;) 19、 在图片上画线draw1.line((100,100,350,300),fill=&quot;red&quot;) ` 20、 图上画圆 第一个元组里面的4个参数代表圆的左上角点和右下角的点（一共俩点）draw1.arc((0,0,400,400),0,360,fill=&quot;red&quot;) 21、 在图片在写文本draw1.text([220,330],&quot;python&quot;,&quot;blue&quot;, font=&quot;&quot;) 第一个参数 指定写入的位置 第二个参数 要写的内容 第三个参数 文字的颜色 第四个参数 指定文字的样式（一般用字体文件）]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-random]]></title>
    <url>%2FPython-random%2F</url>
    <content type="text"><![CDATA[python-random(随机数)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172random.seed(a=None, version=2) # 初始化伪随机数生成器。如果未提供a或者a=None，则使用系统时间为种子。如果a是一个整数，则作为种子。random.getstate()# 返回一个当前生成器的内部状态的对象random.setstate(state)# 传入一个先前利用getstate方法获得的状态对象，使得生成器恢复到这个状态。random.getrandbits(k)# 返回range(0,2**k)之间的一个整数，相当于randrange(0,2**k)random.randrange(stop)# 返回range(0,stop)之间的一个整数random.randrange(start, stop[, step])# 返回range[start,stop)之间的一个整数，可加step，跟range(0,10,2)类似random.randint(a, b)# 返回range[a,b]之间的一个整数，等价于然的range(a,b+1)random.choice(seq)# 从非空序列seq中随机选取一个元素。如果seq为空则弹出 IndexError异常。random.choices(population, weights=None, *, cum_weights=None, k=1)# 3.6版本新增。从population集群中随机抽取K个元素（可重复）。# weights是相对权重列表，cum_weights是累计权重，两个参数不能同时存在。random.shuffle(x[, random])# 随机打乱序列x内元素的排列顺序。只能针对可变的序列，对于不可变序列，请使用下面的sample()方法。random.sample(population, k)# 从population样本或集合中随机抽取K个不重复的元素形成新的序列。# 常用于不重复的随机抽样。返回的是一个新的序列，不会破坏原有序列。# 要从一个整数区间随机抽取一定数量的整数，请使用sample(range(10000000), k=60)类似的方法，# 这非常有效和节省空间。如果k大于population的长度，则弹出ValueError异常。random.random()# 返回一个介于左闭右开[0.0, 1.0)区间的浮点数random.uniform(a, b)# 返回一个介于a和b之间的浮点数。如果a&gt;b，则是b到a之间的浮点数。这里的a和b都有可能出现在结果中。random.triangular(low, high, mode)# 返回一个low &lt;= N &lt;=high的三角形分布的随机数。参数mode指明众数出现位置。random.betavariate(alpha, beta)# β分布。返回的结果在0~1之间random.expovariate(lambd)# 指数分布random.gammavariate(alpha, beta)# 伽玛分布random.gauss(mu, sigma)# 高斯分布random.lognormvariate(mu, sigma)# 对数正态分布random.normalvariate(mu, sigma)# 正态分布random.vonmisesvariate(mu, kappa)# 卡帕分布random.paretovariate(alpha)# 帕累托分布random.weibullvariate(alpha, beta)# 威布尔分布 实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 &gt;&gt;&gt; random() # 随机浮点数: 0.0 &lt;= x &lt; 1.00.37444887175646646 &gt;&gt;&gt; uniform(2.5, 10.0) # 随机浮点数: 2.5 &lt;= x &lt; 10.03.1800146073117523 &gt;&gt;&gt; randrange(10) # 0-9的整数：7 &gt;&gt;&gt; randrange(0, 101, 2) # 0-100的偶数26 &gt;&gt;&gt; choice(['win', 'lose', 'draw']) # 从序列随机选择一个元素'draw' &gt;&gt;&gt; deck = 'ace two three four'.split()&gt;&gt;&gt; shuffle(deck) # 对序列进行洗牌，改变原序列&gt;&gt;&gt; deck['four', 'two', 'ace', 'three'] &gt;&gt;&gt; sample([10, 20, 30, 40, 50], k=4) # 不改变原序列的抽取指定数目样本，并生成新序列[40, 10, 50, 30] &gt;&gt;&gt; # 6次旋转红黑绿轮盘(带权重可重复的取样)，不破坏原序列,weight[18,18,2]&gt;&gt;&gt; choices(['red', 'black', 'green'], [18, 18, 2], k=6)['red', 'green', 'black', 'black', 'red', 'black'] &gt;&gt;&gt; # 德州扑克计算概率Deal 20 cards without replacement from a deck of 52 playing cards&gt;&gt;&gt; # and determine the proportion of cards with a ten-value&gt;&gt;&gt; # (a ten, jack, queen, or king).&gt;&gt;&gt; deck = collections.Counter(tens=16, low_cards=36)&gt;&gt;&gt; seen = sample(list(deck.elements()), k=20)&gt;&gt;&gt; seen.count('tens') / 200.15 &gt;&gt;&gt; # 模拟概率Estimate the probability of getting 5 or more heads from 7 spins&gt;&gt;&gt; # of a biased coin that settles on heads 60% of the time.'H'的概率是0.6，“T”的概率是1-0.6&gt;&gt;&gt; trial = lambda: choices('HT', cum_weights=(0.60, 1.00), k=7).count('H') &gt;= 5&gt;&gt;&gt; sum(trial() for i in range(10000)) / 100000.4169 &gt;&gt;&gt; # Probability of the median of 5 samples being in middle two quartiles&gt;&gt;&gt; trial = lambda : 2500 &lt;= sorted(choices(range(10000), k=5))[2] &lt; 7500&gt;&gt;&gt; sum(trial() for i in range(10000)) / 100000.7958 &gt;&gt;&gt; from statistics import mean&gt;&gt;&gt; from random import choices &gt;&gt;&gt; data = 1, 2, 4, 4, 10&gt;&gt;&gt; means = sorted(mean(choices(data, k=5)) for i in range(20)) # mean是求平均&gt;&gt;&gt; print(f'The sample mean of &#123;mean(data):.1f&#125; has a 90% confidence ' f'interval from &#123;means[1]:.1f&#125; to &#123;means[-2]:.1f&#125;') # 这里的f用法]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用js判断是Pc端或者移动端]]></title>
    <url>%2Fjs%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AFPC%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[使用js判断是Pc端或者移动端源代码：1234567891011function goPAGE() &#123; if ((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) &#123; /*window.location.href="你的手机版地址";*/ alert("mobile") &#125; else &#123; /*window.location.href="你的电脑版地址"; */ alert("pc") &#125;&#125;goPAGE(); 稍微改下：解决了：判断完成后页面不停刷新,停不下来。1234567891011&lt;script&gt; function goPAGE() &#123; if ((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) &#123; return "你的手机版地址"; &#125; else &#123; return "你的电脑版地址"; &#125; &#125; window.location.href = goPAGE();&lt;/script&gt; 还有一种方法是：在移动端的里面只写上跳pc的代码, 在pc端里面只写上跳移动端的代码就可以了。 出现这个问题的原因是：例如:你有pc版的index和移动的index，俩页面。在两个index里面写入了判断代码，当它进入pc版的index/移动的index页面时候会在判断了一次，此番下去变成了一个无限的循环…]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-正则]]></title>
    <url>%2FPython-re%2F</url>
    <content type="text"><![CDATA[python-re(正则) table th:first-of-type { width: 10%; } table:nth-of-type(3) th:first-of-type { width: 20%; } 正则表达式中常用的字符含义 字符 普通字符和11个元字符 普通字符 匹配自身 . 匹配任意除换行符”\n”外的字符(在DOTALL模式中也能匹配换行符 \ 转义字符，使后一个字符改变原来的意思 * 匹配前一个字符0或多次 + 匹配前一个字符1次或无限次 ? 匹配一个字符0次或1次 ^ 匹配字符串开头。在多行模式中匹配每一行的开头 $ 匹配字符串末尾，在多行模式中匹配每一行的末尾 {} {m}匹配前一个字符m次，{m,n}匹配前一个字符m至n次，若省略n，则匹配m至无限次 [] 字符集。对应的位置可以是字符集中任意字符。字符集中的字符可以逐个列出，也可以给出范围，如[abc]或[a-c]。[^abc]表示取反，即非abc。 () 被括起来的表达式将作为分组，从表达式左边开始没遇到一个分组的左括号“（”，编号+1. 所有特殊字符在字符集中都失去其原有的特殊含义。用\反斜杠转义恢复特殊字符的特殊含义。分组表达式作为一个整体，可以后接数量词。表达式中的|仅在该组中有效。| 或。匹配|左右表达式任意一个，从左到右匹配，如果|没有包括在()中，则它的范围是整个正则表达式这里需要强调一下反斜杠\的作用： 反斜杠后边跟元字符去除特殊功能；（即将特殊字符转义成普通字符） 反斜杠后边跟普通字符实现特殊功能；（即预定义字符） 引用序号对应的字组所匹配的字符串。 12a=re.search(r'(tina)(fei)haha\2','tinafeihahafei tinafeihahatina').group()print(a) 结果：tinafeihahafei 2、预定义字符集（可以写在字符集[…]中） 字符 正则表达式中常用的字符含义 \d 数字:[0-9] \D 非数字:[^\d] \s 匹配任何空白字符:[&lt;空格&gt;\t\r\n\f\v] \S 非空白字符:[^\s] \w 匹配包括下划线在内的任何字字符:[A-Za-z0-9_] \W 匹配非字母字符，即匹配特殊字符 \A 仅匹配字符串开头,同^ \Aabc \Z 仅匹配字符串结尾， \b 匹配\w和\W之间，即匹配单词边界匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”r” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \B [^\b] re模块中常用功能函数 1、compile()编译正则表达式模式，返回一个对象的模式。（可以把那些常用的正则表达式编译成正则表达式对象，这样可以提高一点效率。）格式： re.compile(pattern,flags=0)pattern: 编译时用的表达式字符串。 flags 编译标志位，用于修改正则表达式的匹配方式，如：是否区分大小写，多行匹配等。常用的 flags 有： 标志 含义 re.S(DOTALL) 使.匹配包括换行在内的所有字符 re.I（IGNORECASE） 使匹配对大小写不敏感 re.L（LOCALE） 做本地化识别（locale-aware)匹配，法语等 re.M(MULTILINE) 多行匹配，影响^和$ re.X(VERBOSE) 该标志通过给予更灵活的格式以便将正则表达式写得更易于理解 re.U 根据Unicode字符集解析字符，这个标志影响\w,\W,\b,\B 123456import rett = "Tina is a good girl, she is cool, clever, and so on..."rr = re.compile(r'\w*oo\w*')print(rr.findall(tt)) #查找所有包含'oo'的单词执行结果如下：['good', 'cool'] 2、match() 决定RE是否在字符串刚开始的位置匹配。//注：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符’$’ 格式：1234567# re.match(pattern, string, flags=0)print(re.match('com','comwww.runcomoob').group())print(re.match('com','Comwww.runcomoob',re.I).group())# 执行结果如下：comcom 3、search() 格式：re.search(pattern, string, flags=0)re.search函数会在字符串内查找模式匹配,只要找到第一个匹配然后返回，如果字符串没有匹配，则返回None。print(re.search(&#39;\dcom&#39;,&#39;www.4comrunoob.5com&#39;).group())执行结果如下：4com*注：match和search一旦匹配成功，就是一个match object对象，而match object对象有以下方法： group() 返回被 RE 匹配的字符串 start() 返回匹配开始的位置 end() 返回匹配结束的位置 span() 返回一个元组包含匹配 (开始,结束) 的位置 group() 返回re整体匹配的字符串，可以一次输入多个组号，对应组号匹配的字符串。 a. group（）返回re整体匹配的字符串， b. group (n,m) 返回组号为n，m所匹配的字符串，如果组号不存在，则返回indexError异常 c.groups（）groups() 方法返回一个包含正则表达式中所有小组字符串的元组，从 1 到所含的小组号，通常groups()不需要参数，返回一个元组，元组中的元就是正则表达式中定义的组。 1234567import rea = "123abc456" print(re.search("([0-9]*)([a-z]*)([0-9]*)",a).group(0)) #123abc456,返回整体 print(re.search("([0-9]*)([a-z]*)([0-9]*)",a).group(1)) #123 print(re.search("([0-9]*)([a-z]*)([0-9]*)",a).group(2)) #abc print(re.search("([0-9]*)([a-z]*)([0-9]*)",a).group(3)) #456###group(1) 列出第一个括号匹配部分，group(2) 列出第二个括号匹配部分，group(3) 列出第三个括号匹配部分。### 4、findall()re.findall遍历匹配，可以获取字符串中所有匹配的字符串，返回一个列表。 格式：re.findall(pattern, string, flags=0)12p = re.compile(r'\d+')print(p.findall('o1n2m3k4')) 执行结果如下：1['1', '2', '3', '4'] 12345678import rett = "Tina is a good girl, she is cool, clever, and so on..."rr = re.compile(r'\w*oo\w*')print(rr.findall(tt))print(re.findall(r'(\w)*oo(\w)',tt))#()表示子表达式 # 执行结果如下：['good', 'cool'][('g', 'd'), ('c', 'l')] 5、finditer() 搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。找到 RE 匹配的所有子串，并把它们作为一个迭代器返回。格式：re.finditer(pattern, string, flags=0)12345iter = re.finditer(r'\d+','12 drumm44ers drumming, 11 ... 10 ...')for i in iter: print(i) print(i.group()) print(i.span()) 执行结果如下：123456789101112&lt;_sre.SRE_Match object; span=(0, 2), match='12'&gt;12(0, 2)&lt;_sre.SRE_Match object; span=(8, 10), match='44'&gt;44(8, 10)&lt;_sre.SRE_Match object; span=(24, 26), match='11'&gt;11(24, 26)&lt;_sre.SRE_Match object; span=(31, 33), match='10'&gt;10(31, 33) 6、split() 按照能够匹配的子串将string分割后返回列表。可以使用re.split来分割字符串，如：re.split(r&#39;\s+&#39;, text)；将字符串按空格分割成一个单词列表。格式：re.split(pattern, string[, maxsplit])maxsplit用于指定最大分割次数，不指定将全部分割。1print(re.split('\d+','one1two2three3four4five5')) 执行结果如下：1['one', 'two', 'three', 'four', 'five', ''] 7、sub()使用re替换string中每一个匹配的子串后返回替换后的字符串。格式：1re.sub(pattern, repl, string, count) 123import retext = "JGood is a handsome boy, he is cool, clever, and so on..."print(re.sub(r'\s+', '-', text)) 执行结果如下：1JGood-is-a-handsome-boy,-he-is-cool,-clever,-and-so-on... 其中第二个函数是替换后的字符串；本例中为&#39;-&#39;第四个参数指替换个数。默认为0，表示每个匹配项都替换。re.sub还允许使用函数对匹配项的替换进行复杂的处理。如：re.sub(r&#39;\s&#39;, lambda m: &#39;[&#39; + m.group(0) + &#39;]&#39;, text, 0)；将字符串中的空格&#39; &#39;替换为&#39;[ ]&#39;。123import retext = "JGood is a handsome boy, he is cool, clever, and so on..."print(re.sub(r'\s+', lambda m:'['+m.group(0)+']', text,0)) 执行结果如下：1JGood[ ]is[ ]a[ ]handsome[ ]boy,[ ]he[ ]is[ ]cool,[ ]clever,[ ]and[ ]so[ ]on... 8、 subn() 返回替换次数格式：1subn(pattern, repl, string, count=0, flags=0) 123print(re.subn('[1-2]','A','123456abcdef'))print(re.sub("g.t","have",'I get A, I got B ,I gut C'))print(re.subn("g.t","have",'I get A, I got B ,I gut C')) 执行结果如下：123('AA3456abcdef', 2)I have A, I have B ,I have C('I have A, I have B ,I have C', 3) 一些注意点 1、re.match与re.search与re.findall的区别： re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 123456a=re.search('[\d]',"abc33").group()print(a)p=re.match('[\d]',"abc33")print(p)b=re.findall('[\d]',"abc33")print(b) 执行结果：1233None['3', '3'] 2、贪婪匹配与非贪婪匹配 *?,+?,??,{m,n}? 前面的*,+,?等都是贪婪匹配，也就是尽可能匹配，后面加?号使其变成惰性匹配 1234a = re.findall(r"a(\d+?)",'a23b')print(a)b = re.findall(r"a(\d+)",'a23b')print(b) 执行结果：12['2']['23'] 1234a = re.match('&lt;(.*)&gt;','&lt;H1&gt;title&lt;H1&gt;').group()print(a)b = re.match('&lt;(.*?)&gt;','&lt;H1&gt;title&lt;H1&gt;').group()print(b) 执行结果：12&lt;H1&gt;title&lt;H1&gt;&lt;H1&gt; 1234a = re.findall(r"a(\d+)b",'a3333b')print(a)b = re.findall(r"a(\d+?)b",'a3333b')print(b) 执行结果如下：12['3333']['3333'] 这里需要注意的是如果前后均有限定条件的时候，就不存在什么贪婪模式了，非匹配模式失效。复制代码 3、用flags时遇到的小坑 print(re.split(&#39;a&#39;,&#39;1A1a2A3&#39;,re.I))#输出结果并未能区分大小写这是因为re.split(pattern，string，maxsplit,flags)默认是四个参数，当我们传入的三个参数的时候，系统会默认re.I是第三个参数，所以就没起作用。如果想让这里的re.I起作用，写成flags=re.I即可。 正则的小实践 1、匹配电话号码12p = re.compile(r'\d&#123;3&#125;-\d&#123;6&#125;')print(p.findall('010-628888')) 2、匹配IP1re.search(r"(([01]?\d?\d|2[0-4]\d|25[0-5])\.)&#123;3&#125;([01]?\d?\d|2[0-4]\d|25[0-5]\.)","192.168.1.1")]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-时间]]></title>
    <url>%2FPython-time%2F</url>
    <content type="text"><![CDATA[python-time当前时间：1234localtime = time.localtime(time.time())print("本地时间为 :", localtime)# 输出# 本地时间为 : time.struct_time(tm_year=2016, tm_mon=4, tm_mday=7, tm_hour=10, tm_min=3, tm_sec=27, tm_wday=3, tm_yday=98, tm_isdst=0) time.localtime() 不传入参数(时间戳)时， 默认当前时间。 传入指定时间戳时为指定时间。12345678910111213141516171819202122from datetime import datetime,date,timedelta,timetoday = date.today();print(today);print(date.fromtimestamp(1457877369.650549));# 将时间戳的日期输出 print(date.fromordinal(1));# 将天数+最小日期 转换成日期输出 0001-01-01print(date.min);#0001-01-01print(date.max);#9999-12-31print(date.resolution);#1 day, 0:00:00 d = date(2017,1,4);d1 = d.replace(year=2016,day=26);print(d);# d的值不变，print(d1);#2016-01-26print(d.toordinal()); #该日期距离最小日期的天数 print(d.weekday());#返回当前日期是所在周的第几天 0 表示周一 6 表示周日print(d.isoweekday());#返回当前日期是所在周的第几天 1 表示周一 7 表示周日print(d.isocalendar());#返回格式如(year，这一年中的第几周，周几)的元组 print(d.isocalendar()[1]);#返回该日期是这一年中的第几周print(d.isocalendar()[2]);#返回该日期是周几print(d.isoformat());#返回 ISO 8601格式 YYYY-MM-DDprint(d.strftime("%d/%m/%y"));#格式化日期为指定格式print(d.__format__("%d/%m/%y"));#格式化日期为指定格式 格式化日期使用 time 模块的 strftime 方法来格式化日期: 1time.strftime(format[, t]) 实例：1234567891011# 格式化成2016-03-20 11:45:39形式print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) )print(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")) # 格式化成Sat Mar 28 22:24:24 2016形式print(time.strftime("%a %b %d %H:%M:%S %Y", time.localtime()) ) # 将格式字符串转换为时间戳a = "Sat Mar 28 22:24:24 2016"print(time.mktime(time.strptime(a,"%a %b %d %H:%M:%S %Y")) ) python中时间日期格式化符号： —- %y 两位数的年份表示（00-99） %B 本地完整的月份名称 %Y 四位数的年份表示（000-9999） %c 本地相应的日期表示和时间表示 %m 月份（01-12） %j 年内的一天（001-366） %d 月内中的一天（0-31） %p 本地A.M.或P.M.的等价符 %H 24小时制小时数（0-23） %U 一年中的星期数（00-53）星期天为星期的开始 %I 12小时制小时数（01-12） %w 星期（0-6），星期天为星期的开始 %M 分钟数（00=59） %W 一年中的星期数（00-53）星期一为星期的开始 %S 秒（00-59） %x 本地相应的日期表示 %a 本地简化星期名称 %X 本地相应的时间表示 %A 本地完整星期名称 %Z 当前时区的名称 %b 本地简化的月份名称 %% %号本身]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-dict]]></title>
    <url>%2FPython-%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[python数据类型之dict1、clear:删除所有元素12345#D.clear() -&gt; None. Remove all items from Ddic_a =&#123;1:'kong',2:'zha',3:'gen'&#125;dic_a.clear()print(dic_a)结果：&#123;&#125; 2、fromkeys():从序列键和值生成字典的key,value来构建一个新字典12345678#dict.fromkeys(seq[, value]))seq:是为字典的键准备的value:是字典的默认值seq = ('Name','Age','Sex')new_dic = dict.fromkeys(seq,10)print(new_dic)结果：&#123;'Age': 10, 'Sex': 10, 'Name': 10&#125; 3、get:获取字典值12345#get(self, k, d=None)如果字典中没有1键，则值返回默认值10，如果不返回默认值，则返回Nonedic = &#123;1:'kong',2:'zha'&#125;print(dic.get(1,10))结果：'kong' 4、items:返回一个类集合对象123dic = &#123;1:'kong',2:'zha'&#125;print(dic.items())结果：dict_items([(1, 'kong'), (2, 'zha')]) 5、keys:返回一个类集合对象123456789dic = &#123;1:'kong',2:'zha'&#125;new_dic = dic.keys()print(new_dic)for x in new_dic: print(x)结果：dict_keys([1, 2])12 6、pop:删除字典指定的键值，返回一个value值，必须指定键删除1234567#D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding valuedic = &#123;1:'kong',2:'zha'&#125;print(dic.pop(1))print(dic)结果：kong&#123;2: 'zha'&#125; 7、popitem:随机移除字典的键值对，返回一个元组，如果字典为空则报错12345678#D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty.dic = &#123;1:'kong',2:'zha',3:'gen'&#125;print(dic.popitem())print(dic)结果：(1, 'kong')&#123;2: 'zha', 3: 'gen'&#125; 8、setdefault:如果键在字典中，返回键对应的值，如果键不在字典中，向字典中插入这个键值12345678#D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in Ddic = &#123;1:'kong',2:'zha',3:'gen',4:'ff',5:'pp'&#125;pp = dic.setdefault(6,'ppp')print(dic)print(pp)结果：&#123;1: 'kong', 2: 'zha', 3: 'gen', 4: 'ff', 5: 'pp', 6: 'ppp'&#125;ppp 9、update:用dic2更新dic1:如果dic2的键在dic1中不存在，则dic2插入到dic1,否则更用dic2的键值，更新dic112345678dic1 = &#123;'Name':'kong','Age':33&#125;dic2 = &#123;'Name':'Hucli','Sex':'M'&#125;print(dic1,dic2)dic1.update(dic2)print(dic1)结果：&#123;'Age': 33, 'Name': 'kong'&#125; &#123;'Name': 'Hucli', 'Sex': 'M'&#125;&#123;'Age': 33, 'Name': 'Hucli', 'Sex': 'M'&#125; 10、values:返回字典的所有值1234#D.values() -&gt; an object providing a view on D's valuesdic1 = &#123;'Name':'kong','Age':33&#125;print(dic1.values())结果：dict_values([33, 'kong']) 总结： 方法 描述 D.clear() 移除D中的所有项 D.copy() 返回D的副本 D.fromkeys(seq[,val]) 返回从seq中获得的键和被设置为val的值的字典。可做类方法调用 D.get(key[,default]) 如果D[key]存在，将其返回；否则返回给定的默认值None D.has_key(key) 检查D是否有给定键key D.items() 返回表示D项的(键，值)对列表 D.iteritems() 从D.items()返回的(键，值)对中返回一个可迭代的对象 D.iterkeys() 从D的键中返回一个可迭代对象 D.itervalues() 从D的值中返回一个可迭代对象 D.keys() 返回D键的列表 D.pop(key[,d]) 移除并且返回对应给定键key或给定的默认值D的值 D.popitem() 从D中移除任意一项，并将其作为(键，值)对返回 D.setdefault(key[,default]) 如果D[key]存在则将其返回；否则返回默认值None D.update(other) 将other中的每一项加入到D中。 D.values() 返回D中值的列表]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-list方法]]></title>
    <url>%2FPython-list%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[为了能方便记忆，想看就看。这里记录一下Python3.x的list方法。 table th:first-of-type { width: 10%; } table th:nth-of-type(2) { width: 25%; } table:nth-of-type(3) th:first-of-type { width: 30%; } table:nth-of-type(3) th:nth-of-type(2) { width: 25%; } table:nth-of-type(4) th:first-of-type { width: 30%; } table:nth-of-type(4) th:nth-of-type(2) { width: 25%; } list(seq) : 将元组转换为列表tuple(seq) : 将列表转换为元组。 Python列表函数&amp;方法 序号 函数 描述 1 len(list) 列表元素个数 2 max(list) 返回列表元素最大值 3 min(list) 返回列表元素最小值 4 list(seq) 将元组转换为列表 序号 方法 描述 1 list.append(obj) 在列表末尾添加新的对象 2 list.count(obj) 统计某个元素在列表中出现的次数 3 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） 4 list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 5 list.insert(index, obj) 将对象插入列表 6 list.pop([index=-1]]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 7 list.remove(obj) 移除列表中某个值的第一个匹配项 8 list.reverse() 反向列表中元素 9 list.sort(cmp=None, key=None, reverse=False) 对原列表进行排序 10 list.clear() 清空列表 11 list.copy() 复制列表 列表截取 序号 结果 描述 L[2] ‘Taobao’ 读取第三个元素 L[-2] ‘Runoob’ 从右侧开始读取倒数第二个元素: count from the right L[1:] [‘Runoob’, ‘Taobao’] 输出从第二个元素开始后的所有元素 列表脚本操作符 序号 结果 描述 len([1, 2, 3]) 3 长度 [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合 [‘Hi!’] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 重复 3 in [1, 2, 3] True 元素是否存在于列表中 for x in [1, 2, 3]: print(x, end=” “) 1 2 3 迭代]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-File]]></title>
    <url>%2FPython-file%2F</url>
    <content type="text"><![CDATA[仅仅是为了自己方便看。file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：file = open(‘test.txt’, ‘wb’) table th:first-of-type { width: 10%; } table th:nth-of-type(2) { width: 25%; } 序号 方法 描述 1 file.close() 关闭文件。关闭后文件不能再进行读写操作。 2 file.flush() 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 3 file.fileno() 返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 4 file.isatty() 如果文件连接到一个终端设备返回 True，否则返回 False。 5 file.next() 返回文件下一行。 6 file.read([size]) 从文件读取指定的字节数，如果未给定或为负则读取所有。 7 file.readline([size]) 读取整行，包括 “\n” 字符。 8 file.readlines([sizeint]) 读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 9 file.seek(offset[, whence]) 设置文件当前位置 10 file.tell() 返回文件当前位置。 11 file.truncate([size]) 从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 Widnows 系统下的换行代表2个字符大小。 12 file.write(str) 将字符串写入文件，返回的是写入的字符长度。 13 file.writelines(sequence) 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-OS]]></title>
    <url>%2FPython-OS%2F</url>
    <content type="text"><![CDATA[仅仅是为了自己方便看。os 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示： table th:first-of-type { width: 5%; } table th:nth-of-type(2) { width: 25%; } 序号 方法 描述 1 os.access(path, mode) 检验权限模式 2 os.chdir(path) 改变当前工作目录 3 os.chflags(path, flags) 设置路径的标记为数字标记。 4 os.chmod(path, mode) 更改权限 5 os.chown(path, uid, gid) 更改文件所有者 6 os.chroot(path) 改变当前进程的根目录 7 os.close(fd) 关闭文件描述符 fd 8 os.closerange(fd_low, fd_high) 关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略 9 os.dup(fd) 复制文件描述符 fd 10 os.dup2(fd, fd2) 将一个文件描述符 fd 复制到另一个 fd2 11 os.fchdir(fd) 通过文件描述符改变当前工作目录 12 os.fchmod(fd, mode) 改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。 13 os.fchown(fd, uid, gid) 修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。 14 os.fdatasync(fd) 强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。 15 os.fdopen(fd[, mode[, bufsize]]) 通过文件描述符 fd 创建一个文件对象，并返回这个文件对象 16 os.fpathconf(fd, name) 返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。 17 os.fstat(fd) 返回文件描述符fd的状态，像stat()。 18 os.fstatvfs(fd) 返回包含文件描述符fd的文件的文件系统的信息，像 statvfs() 19 os.fsync(fd) 强制将文件描述符为fd的文件写入硬盘。 20 os.ftruncate(fd, length) 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。 21 os.getcwd() 返回当前工作目录 22 os.getcwdu() 返回一个当前工作目录的Unicode对象 23 os.isatty(fd) 如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。 24 os.lchflags(path, flags) 设置路径的标记为数字标记，类似 chflags()，但是没有软链接 25 os.lchmod(path, mode) 修改连接文件权限 26 os.lchown(path, uid, gid) 更改文件所有者，类似 chown，但是不追踪链接。 27 os.link(src, dst) 创建硬链接，名为参数 dst，指向参数 src 28 os.listdir(path) 返回path指定的文件夹包含的文件或文件夹的名字的列表。 29 os.lseek(fd, pos, how) 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效 30 os.lstat(path) 像stat(),但是没有软链接 31 os.major(device) 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。 32 os.makedev(major, minor) 以major和minor设备号组成一个原始设备号 33 os.makedirs(path[, mode]) 递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。 34 os.minor(device) 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。 35 os.mkdir(path[, mode]) 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。 36 os.mkfifo(path[, mode]) 创建命名管道，mode 为数字，默认为 0666 (八进制) 37 os.mknod(filename[, mode=0600, device]) 创建 一个名为filename文件系统节点（文件，设备特别文件或者命名pipe 38os.open(file, flags[, mode])打开一个文件，并且设置需要的打开选项，mode参数是可选的 39 os.openpty() 打开一个新的伪终端对。返回 pty 和 tty的文件描述符。 40 os.pathconf(path, name) 返回相关文件的系统配置信息。 41 os.pipe() 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写 42 os.popen(command[, mode[, bufsize]]) 从一个 command 打开一个管道 43 os.read(fd, n) 从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。 44 os.readlink(path) 返回软链接所指向的文件 45 os.remove(path) 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。 46 os.removedirs(path) 递归删除目录。 47 os.rename(src, dst) 重命名文件或目录，从 src 到 dst 48 os.renames(old, new) 递归地对目录进行更名，也可以对文件进行更名。 49 os.rmdir(path) 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。 50 os.stat(path) 获取path指定的路径的信息，功能等同于C API中的stat()系统调用。 51 os.stat_float_times([newvalue]) 决定 stat_result 是否以float对象显示时间 52os.statvfs(path) 获取指定路径的文件系统统计信息 53 os.symlink(src, dst) 创建一个软链接 54 os.tcgetpgrp(fd) 返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组 55 os.tcsetpgrp(fd, pg) 设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。 56 os.tempnam([dir[, prefix]]) Python3 中已删除。返回唯一的路径名用于创建临时文件。 57 os.tmpfile() Python3 中已删除。返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。 58 os.tmpnam() Python3 中已删除。为创建一个临时文件返回一个唯一的路径 59 os.ttyname(fd) 返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。 60 os.unlink(path) 删除文件路径 61 os.utime(path, times) 返回指定的path文件的访问和修改的时间。 62 os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]]) 输出在文件夹中的文件名通过在树中游走，向上或者向下。 63 os.write(fd, str) 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[听几米唱歌]]></title>
    <url>%2F18-7-02%2F</url>
    <content type="text"><![CDATA[信不信由你 谁都不会相信这是真的。装著猪的气球，可以飞上天，连猪自己都不相信。。直到一声巨响，气球破了，猪仔从高空直直落下，摔断了一条猪腿，大家才高高兴兴兴的相信了]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[听几米唱歌]]></title>
    <url>%2F18-6-28%2F</url>
    <content type="text"><![CDATA[魔幻花墙 种一颗开满紫色小花的树，把看风景的小窗包起来。蓝色的天空，绿色的草地。银灰色的小兔，白色的墙。任何人站在这扇窗户里，都会变得美丽。 疲惫人生 大家都说做人好累，我也这么觉得。要戴上假发、戴上面具、戴上眼镜、戴上笑容。穿上内衣、穿上外衣、再穿上外套，穿上内裤、穿上外裤、再系上皮带。穿上袜子、穿上鞋子、再绑上鞋带，天天都得如此，直到上天堂。 浮沉风景 有人浮起来，有人沉下去。楼顶的风景与楼底的风景，永远不会一样，谁也别羡慕谁。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-number方法]]></title>
    <url>%2FPython-number%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[为了能方便记忆，想看就看。这里记录一下Python3.x的number方法。 table th:first-of-type { width: 10%; } table th:nth-of-type(2) { width: 25%; } Python 数字类型转换有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。 int(x) 将x转换为一个整数。 float(x) 将x转换到一个浮点数。 complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。 complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。 数学函数 序号 方法 描述 1 abs(x) 返回 x 的绝对值。 2 math.ceil(8.1) 向上取整。 3 math.exp() 返回x的指数,e^x。 4 math.fabs() 方法返回数字的绝对值，如math.fabs(-10) 返回10.0。fabs() 函数类似于 abs() 函数，但是他有两点区别:1. abs() 是内置函数。 fabs() 函数在 math 模块中定义。2.fabs() 函数只对浮点型跟整型数值有效。 abs() 还可以运用在复数中。 5 math.floor(x) 返回数字的下舍整数，小于或等于 x 6 math.log(x) 方法返回x的自然对数，x &gt; 0 7 math.log10() 方法返回以10为基数的x对数，x&gt;0。 8 max(5, 10) 方法返回给定参数的最大值，参数可以为序列。 9 min([14,64,21]) 方法返回给定参数的最大值，参数可以为序列。 10 math.modf(x) 方法返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示例如：math.modf(100.12) =&gt; (0.12000000000000455, 100.0) 11 math.pow(x, y[, z]) 函数是计算x的y次方，如果z在存在，则再对结果进行取模，其结果等效于pow(x,y) %z返回值是浮点型。 12 round( x [, n] ) x – 数字表达式。n – 表示从小数点位数，其中 x 需要四舍五入，默认值为 0。方法返回浮点数x的四舍五入值。 13 math.sqrt(x) 方法返回数字x的平方根。 随机数函数随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。 序号 方法 描述 1 random.choice( seq ) seq – 可以是一个列表，元组或字符串。返回一个列表，元组或字符串中的随机项。 2 random.randrange ([start,] stop [,step]) start – 指定范围内的开始值，包含在范围内。stop – 指定范围内的结束值，不包含在范围内。step – 指定递增基数。返回指定递增基数集合中的一个随机数，基数缺省值为1。 3 random.random() 返回随机生成的一个实数，它在[0,1)范围内。 4 random.seed ( [x] ) 改变随机数生成器的种子，可以在调用其他随机模块函数之前调用此函数。 5 random.shuffle (lst ) 将序列的所有元素随机排序。 6 random.uniform(x, y) 将随机生成下一个实数，它在[x,y]范围内。 实例以下展示了使用 seed() 方法的实例：123456789101112131415import randomrandom.seed()print ("使用默认种子生成随机数：", random.random())random.seed(10)print ("使用整数种子生成随机数：", random.random())random.seed("hello",2)print ("使用字符串种子生成随机数：", random.random())以上实例运行后输出结果为：使用默认种子生成随机数： 0.9186252047469824使用整数种子生成随机数： 0.5714025946899135使用字符串种子生成随机数： 0.3537754404730722 三角函数 序号 方法 描述 1 math.acos(x) 返回x的反余弦弧度值。 2 math.asin(x) 返回x的反正弦弧度值。 3 math.atan(x) 返回x的反正切弧度值。 4 math.atan2(y, x) 返回给定的 X 及 Y 坐标值的反正切值。 5 math.cos(x) 返回x的弧度的余弦值。 6 math.hypot(x, y) 返回欧几里德范数 sqrt(xx + yy)。 7 math.sin(x) 返回的x弧度的正弦值。 8 math.tan(x) 返回x弧度的正切值。 9 math.degrees(x) 将弧度转换为角度,如degrees(math.pi/2)， 返回90.0 10 math.radians(x) 将角度转换为弧]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-字符串方法]]></title>
    <url>%2FPython-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[为了能方便记忆，想看就看。这里记录一下Python3.x的字符串方法。 table th:first-of-type { width: 5%; } table th:nth-of-type(2) { width: 25%; } 增： 序号 方法 描述 1 string.zfill() 方法返回指定长度的字符串，原字符串右对齐，前面填充0。 2 string.join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。 3 string.ljust() 方法返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。 4 string.center(51, ‘*’) 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。 5 string.rjust(width,[, fillchar]) 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串 删： 序号 方法 描述 1 string.strip() 方法用于移除字符串头尾指定的字符（默认为空格）或字符序列。注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。 2 string.rstrip() 删除 string 字符串末尾的指定字符（默认为空格） 3 string.lstrip() 方法用于截掉字符串左边的空格或指定字符。 改： 序号 方法 描述 1 string.swapcase() 方法用于对字符串的大小写字母进行转换。返回大小写字母转换后生成的新字符串。 2 string.upper() 转换字符串中的小写字母为大写 3 string.lower() 方法转换字符串中所有大写字符为小写。 4 string.capitalize() 字符串的首字母变大写 5 string.title() 返回”标题化”的字符串,就是说所有单词的首个字母转化为大写，其余字母均为小写 6 string.replace(old, new[, max]) 把字符串中的 old（旧字符串） 替换成 new(新字符串)如果指定第三个参数max，则替换不超过max次 7 str.split(str=””, num=string.count(str)) 通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串 8 string.expandtabs(16) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。 9 str.maketrans() intab = “aeiou” outtab = “12345” trantab = str.maketrans(intab, outtab) 指定替换 a=&gt;1, e=&gt;2, i=&gt;3, o=&gt;4, u=&gt;5 str = “this is string example….wow!!!” str.translate(trantab) translate 开始替换str里面的 a, e, i, o, u 为 1,2,3,4,5 10 translate() 方法根据参数table给出的表(包含 256 个字符)转换字符串的字符,要过滤掉的字符放到 deletechars 参数中。translate()方法语法：str.translate(table)bytes.translate(table[, delete]) bytearray.translate(table[, delete]) table – 翻译表，翻译表是通过 maketrans() 方法转换而来。deletechars – 字符串中要过滤的字符列表。 11 splitlines() 按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。str.splitlines([keepends])keepends – 在输出结果里是否去掉换行符(‘\r’, ‘\r\n’, \n’)，默认为 False，不包含换行符，如果为 True，则保留换行符。 查： 序号 方法 描述 1 string.isdecimal() 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。 2 string.find(‘k’, 0, 7) 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1 3 index(str, beg=0, end=len(string) 跟find()方法一样，只不过如果str不在字符串中会报一个异常. 4 string.rfind(str, beg=0,end=len(string)) 类似于 find()函数，不过是从右边开始查找. 5 string.rindex( str, beg=0, end=len(string) 类似于 index()，不过是从右边开始. 6 string.isupper() 检测字符串中所有的字母是否都为大写。 7 string.islower() 如果都是小写返回True 否则返回False 8 string.istitle() 方法检测字符串中所有的单词拼写首字母是否为大写，且其他字母为小写。 9 max(string) 返回字符串 str 中最大的字母。 10 min(string) 返回字符串 str 中最小的字母。 11 string.isnumeric() 检测字符串是否只由数字组成。这种方法是只针对unicode对象。如果字符串中只包含数字字符，则返回 True，否则返回 False。 12 string.isalnum() 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False注：必须是全字母或者全数字，不能有空格等。 13 string.isalpha() 如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False 14 string.isdigit() 如果字符串只包含数字则返回 True 否则返回 False.注：必须是全数字，不能有空格等。 15 string.isspace() 如果字符串中只包含空白，则返回 True，否则返回 False. 16 string.count(‘l’, 0, 3) 用于统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置。 17 string.endswith(‘l’, 0, 3) 检查字符串是否以 obj 结束，如果设置第二个和第三个参数，则判断在指定的范围内是否以 obj 结束如果是，返回 True,否则返回 False. 18 string.startswith() 方法用于检查字符串是否是以指定子字符串开头，如果是则返回 True，否则返回 False。如果参数 beg 和 end 指定值，则在指定范围内检查。 19 len(string) 方法返回对象（字符、列表、元组等）长度或项目个数。 字符串的格式化Python之%s%d%f %s 字符串12345678910111213141516171819202122232425262728293031string="hello" #%s打印时结果是hello print "string=%s" % string # output: string=hello #%2s意思是字符串长度为2，当原字符串的长度超过2时，按原长度打印，所以%2s的打印结果还是hello print "string=%2s" % string # output: string=hello #%7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串左侧补空格， #所以%7s的打印结果是 hello print "string=%7s" % string # output: string= hello #%-7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串右侧补空格， #所以%-7s的打印结果是 hello print "string=%-7s!" % string # output: string=hello ! #%.2s意思是截取字符串的前2个字符，所以%.2s的打印结果是he print "string=%.2s" % string # output: string=he #%.7s意思是截取字符串的前7个字符，当原字符串长度小于7时，即是字符串本身， #所以%.7s的打印结果是hello print "string=%.7s" % string # output: string=hello #%a.bs这种格式是上面两种格式的综合，首先根据小数点后面的数b截取字符串， #当截取的字符串长度小于a时，还需要在其左侧补空格 print "string=%7.2s" % string # output: string= he print "string=%2.7s" % string # output: string=hello print "string=%10.7s" % string # output: string= hello #还可以用%*.*s来表示精度，两个*的值分别在后面小括号的前两位数值指定 print "string=%*.*s" % (7,2,string) # output: string= he %d 整型 123456789101112131415161718192021222324252627282930313233343536num=14 #%d打印时结果是14 print &quot;num=%d&quot; % num # output: num=14 #%1d意思是打印结果为1位整数，当整数的位数超过1位时，按整数原值打印，所以%1d的打印结果还是14 print &quot;num=%1d&quot; % num # output: num=14 #%3d意思是打印结果为3位整数，当整数的位数不够3位时，在整数左侧补空格，所以%3d的打印结果是 14 print &quot;num=%3d&quot; % num # output: num= 14 #%-3d意思是打印结果为3位整数，当整数的位数不够3位时，在整数右侧补空格，所以%3d的打印结果是14_ print &quot;num=%-3d&quot; % num # output: num=14_ #%05d意思是打印结果为5位整数，当整数的位数不够5位时，在整数左侧补0，所以%05d的打印结果是00014 print &quot;num=%05d&quot; % num # output: num=00014 #%.3d小数点后面的3意思是打印结果为3位整数， #当整数的位数不够3位时，在整数左侧补0，所以%.3d的打印结果是014 print &quot;num=%.3d&quot; % num # output: num=014 #%.0003d小数点后面的0003和3一样，都表示3，意思是打印结果为3位整数， #当整数的位数不够3位时，在整数左侧补0，所以%.3d的打印结果还是014 print &quot;num=%.0003d&quot; % num # output: num=014 #%5.3d是两种补齐方式的综合，当整数的位数不够3时，先在左侧补0，还是不够5位时，再在左侧补空格， #规则就是补0优先，最终的长度选数值较大的那个，所以%5.3d的打印结果还是 014 print &quot;num=%5.3d&quot; % num # output: num= 014 #%05.3d是两种补齐方式的综合，当整数的位数不够3时，先在左侧补0，还是不够5位时， #由于是05，再在左侧补0，最终的长度选数值较大的那个，所以%05.3d的打印结果还是00014 print &quot;num=%05.3d&quot; % num # output: num=00014 #还可以用%*.*d来表示精度，两个*的值分别在后面小括号的前两位数值指定 #如下，不过这种方式04就失去补0的功能，只能补空格，只有小数点后面的3才能补0 print &quot;num=%*.*d&quot; % (04,3,num) # output: num= 014 %f 浮点型 12345678910111213141516171819202122import math #%a.bf，a表示浮点数的打印长度，b表示浮点数小数点后面的精度 #只是%f时表示原值，默认是小数点后5位数 print &quot;PI=%f&quot; % math.pi # output: PI=3.141593 #只是%9f时，表示打印长度9位数，小数点也占一位，不够左侧补空格 print &quot;PI=%9f&quot; % math.pi # output: PI=_3.141593 #只有.没有后面的数字时，表示去掉小数输出整数，03表示不够3位数左侧补0 print &quot;PI=%03.f&quot; % math.pi # output: PI=003 #%6.3f表示小数点后面精确到3位，总长度6位数，包括小数点，不够左侧补空格 print &quot;PI=%6.3f&quot; % math.pi # output: PI=_3.142 #%-6.3f表示小数点后面精确到3位，总长度6位数，包括小数点，不够右侧补空格 print &quot;PI=%-6.3f&quot; % math.pi # output: PI=3.142_ #还可以用%*.*f来表示精度，两个*的值分别在后面小括号的前两位数值指定 #如下，不过这种方式06就失去补0的功能，只能补空格 print &quot;PI=%*.*f&quot; % (06,3,math.pi) # output: PI=_3.142]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[听几米唱歌]]></title>
    <url>%2F18-6-20%2F</url>
    <content type="text"><![CDATA[摘星星 摘不到的星星，总是最闪亮的。溜掉的小鱼，总是最美丽的。错过的电影，总是最好看的。失去的情人，总是最懂我的。我始终不明白，这究竟是什么道理。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[听几米唱歌]]></title>
    <url>%2F18-6-13%2F</url>
    <content type="text"><![CDATA[懒人的愿望 你一定要这么匆忙地往前走吗？可不可以休息一下。像我一样，偶尔睡个懒觉，偶尔发呆，偶尔出错，偶尔闹闹情绪，偶尔耍赖……你一定要如此坚定，严格地向前走吗？弄得大家都精疲力竭的老了！]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-高级特性]]></title>
    <url>%2Fpython-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[切片切片操作十分有用。我们先创建一个0-99的数列：123&gt;&gt;&gt; L = list(range(100))&gt;&gt;&gt; L[0, 1, 2, 3, ..., 99] 可以通过切片轻松取出某一段数列。比如前10个数：12&gt;&gt;&gt; L[:10][0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 后10个数：12&gt;&gt;&gt; L[-10:][90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 前11-20个数：12&gt;&gt;&gt; L[10:20][10, 11, 12, 13, 14, 15, 16, 17, 18, 19] 前10个数，每两个取一个：12&gt;&gt;&gt; L[:10:2][0, 2, 4, 6, 8] 所有数，每5个取一个：12&gt;&gt;&gt; L[::5][0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] 甚至什么都不写，只写[:]就可以原样复制一个list：12&gt;&gt;&gt; L[:][0, 1, 2, 3, ..., 99] tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：12&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3](0, 1, 2) 字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：1234&gt;&gt;&gt; 'ABCDEFG'[:3]'ABC'&gt;&gt;&gt; 'ABCDEFG'[::2]'ACEG' generator要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：123456&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 通过next()函数获得generator的下一个返回值：12next(g)0 generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。通过for循环来迭代它，并且不需要关心StopIteration的错误。123g = (x * x for x in range(10))for n in g: print(n) 定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator. generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中 迭代器 (Iterable)可以直接作用于for循环的数据类型有以下几种： 一类是集合数据类型，如list、tuple、dict、set、str等；一类是generator，包括生成器和带yield的generator function。这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。可以使用isinstance()判断一个对象是否是Iterable对象 而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。可以使用isinstance()判断一个对象是否是Iterator对象 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。把list、dict、str等Iterable变成Iterator可以使用iter()函数：1234&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter('abc'), Iterator)True 为什么list、dict、str等数据类型不是Iterator？因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。 小结: 凡是可作用于for循环的对象都是Iterable类型； 凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列； 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。 Python的for循环本质上就是通过不断调用next()函数实现的，例如：123456789101112131415for x in [1, 2, 3, 4, 5]: pass#实际上完全等价于：# 首先获得Iterator对象:it = iter([1, 2, 3, 4, 5])# 循环:while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[森林唱游]]></title>
    <url>%2F18-6-01%2F</url>
    <content type="text"><![CDATA[奇遇 我遇到猫在潜水，却没遇到你；我遇到狗在攀岩，却没遇到你；我遇到夏天飘雪，却没遇到你；我遇到冬天刮台风，却没遇到你；我遇到猪都学会结网了，却没遇到你……我遇到所有的不平凡，却一直遇不到平凡的你。——几米 《听几米唱歌》]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杨辉三角]]></title>
    <url>%2Ftriangles%2F</url>
    <content type="text"><![CDATA[近日到廖雪峰老师的网站上学习Python的generator,尝试解析下方便记忆:题目是: 杨辉三角定义如下： 1234567891011 1 / \ 1 1 / \ / \ 1 2 1 / \ / \ / \ 1 3 3 1 / \ / \ / \ / \ 1 4 6 4 1 / \ / \ / \ / \ / \1 5 10 10 5 1 把每一行看做一个list，试写一个generator，不断输出下一行的list. 答案是:12345def triangles(): L = [1] while True: yield L L= [(L + [0])[i] + ([0] + L)[i] for i in range(len(L)+1)] L = [1] 用于输出第一行的 1重点是L= [(L + [0])[i] + ([0] + L)[i] for i in range(len(L)+1)]这一行.12345678910111213141516171819202122首先看下 ( L + [0] ) --&gt; [ 1, 0 ] 俩数组相加相当于数组拼接.同理 ( [0] + L ) --&gt; [0, 1]L = [(L + [0])[i] + ([0] + L)[i] for i in range(len(L)+1)]等同于L = [ [ 1, 0 ][i] + [0, 1][i] for i in range(len(L)+1) ]range(len(L)+1) 这里 +1 的目的是因为 L + [0] 这里导致 len 加了 1 ;range(len(L)+1) --&gt; 0, 1 当 i = 0 时: L = [ 1 + 0 ]当 i = 1 时:L = [ 0 + 1 ]结果: L = [ 1, 1 ]当 L = [ 1, 1 ] 时, 如下:[1, 1, 0] [0, 1, 1] [1, 2, 1] 因本人是新手, 如有错误请告知.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汉诺塔 -- Python]]></title>
    <url>%2F%E6%B1%89%E8%AF%BA%E5%A1%94%E8%AF%A6%E8%A7%A3-python%2F</url>
    <content type="text"><![CDATA[最主要的还是要搞明白 递归的意思12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364move(3,'A', 'B', 'C')def move(3,a,b,c): 这里传入参数为 move(3, 'A', 'B', 'C') if n==1: print(a,'-&gt;',c) else: move(n-1,a,c,b) 改变参数顺序 -&gt; 这里传入参数为 move(2, 'A', 'C', 'B') | | ▼ move(n, a, b, c) 参数发生变化: n = 2 a = 'A' b = 'C' c = 'B' 牢记此处参数的值 if n == 1 : n = 2 条件不成立 不执行 print(a,'--&gt;',c) else : move(n-1,a,c,b) 改变参数顺序 -&gt; 这里传入参数为 move(1, 'A', 'B', 'C') | | ▼ move(n, a, b, c) 参数发生变化: n = 1 a = 'A' b = 'B' c = 'C' if n == 1 : n = 1 条件成立 执行 print(a,'--&gt;',c) ① 输出 A --&gt; C .执行完毕,回退 &lt;--回退完毕-----&lt;-----&lt;------&lt;------&lt;---- | else : | move(n-1,a,c,b) | move(1,a,b,c) | move(n-1,b,a,c) ▼向下执行 move(1,a,b,c) n = 2 a = 'A' b = 'C' c = 'B' | | ▼ move(n, a, b, c) 这里传入参数为 move(1, 'A', 'C', 'B') a = 'A' b = 'C' c = 'B' if n == 1 : n = 1 条件成立 执行完毕 print(a,'--&gt;',c) **② 输出 A --&gt; B** .执行完毕,回退 &lt;--回退完毕-----&lt;-----&lt;------&lt;------&lt;---- | else : | move(n-1,a,c,b) | move(1,a,b,c) | move(n-1,b,a,c) ▼向下执行 n = 2 a = 'A' b = 'C' c = 'B' move(n-1,b,a,c) 改变参数顺序 -&gt; 这里传入参数为 move(1, 'C', 'A', 'B') | | ▼ move(n, a, b, c) 这里传入参数为 move(1, 'C', 'A', 'B') a = 'C' b = 'A' c = 'B' if n == 1 : n = 1 条件成立 执行完毕 print(a,'--&gt;',c) ③ 输出 C --&gt; B .执行完毕,回退 &lt;--回退完毕-----&lt;-----&lt;------&lt;------&lt;---- | else : | move(n-1,a,c,b) | move(1,a,b,c) | move(n-1,b,a,c) ▼ &lt;-------- | ▼ move(1,a,b,c) 参数为: n = 1 a = 'A' b = 'B' c = 'C' ④ 输出 A --&gt; C move(n-1,b,a,c) 同理 -&gt; 参数变化 执行顺序同上 奉上代码:123456789def move(n,a,b,c): if n==1: print(a,'-&gt;',c) else: move(n-1,a,c,b) move(1,a,b,c) move(n-1,b,a,c) move(3,'A', 'B', 'C')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 函数]]></title>
    <url>%2Fpython%20%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。pass 语句什么都不做, 用来占位、定义空函数、满足某条件的时候暂时不做处理.12if 18 &gt; 9 : pass //这里没有pass 将会报错 给函数添加一个检查参数的判断1234567def my_abs(x): if not isinstance(x, (int, float)): raise TypeError('bad operand type') if x &gt;= 0: return x else: return -x 添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误. 一个求一元二次方程的函数:12345678910111213141516171819def quadratic(a,b,c): if a == 0 : raise TypeError('二次项系数不能为 0') if not isinstance(a,(int,float)): raise TypeError('参数错误') if not isinstance(b,(int,float)): raise TypeError('参数错误') if not isinstance(c,(int,float)): raise TypeError('参数错误') num = b*b - 4*a*c if num &lt; 0 : return '无解' elif num == 0 : x = -b / 2*a return x else : x1 = (-b - math.sqrt(num))/(2*a) x2 = (-b + math.sqrt(num))/(2*a) return x2,x1 默认参数函数可以有默认参数:12345def mrceel(name, age=18): print('name=',name) print('age=',age)print(mrceel('cyq')) 定义默认参数要牢记一点：默认参数必须指向不变对象！ 先定义一个函数，传入一个list，添加一个END再返回：123def add_end(L=[]): L.append('END') return L 当你正常调用时，结果似乎不错：1234&gt;&gt;&gt; add_end([1, 2, 3])[1, 2, 3, 'END']&gt;&gt;&gt; add_end(['x', 'y', 'z'])['x', 'y', 'z', 'END'] 当你使用默认参数调用时，一开始结果也是对的：12&gt;&gt;&gt; add_end()['END'] 但是，再次调用add_end()时，结果就不对了：1234&gt;&gt;&gt; add_end()['END', 'END']&gt;&gt;&gt; add_end()['END', 'END', 'END'] 原因解释如下： Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。 可变参数12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：1234&gt;&gt;&gt; calc(1, 2)5&gt;&gt;&gt; calc()0 如果已经有一个list或者tuple，要调用一个可变参数,在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：123&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(*nums)14 *nums表示把nums这个list的所有元素作为可变参数传进去。 关键字参数可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：12def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw) 函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：12&gt;&gt;&gt; person('Michael', 30)name: Michael age: 30 other: &#123;&#125; 也可以传入任意个数的关键字参数：1234&gt;&gt;&gt; person('Bob', 35, city='Beijing')name: Bob age: 35 other: &#123;'city': 'Beijing'&#125;&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')name: Adam age: 45 other: &#123;'gender': 'M', 'job': 'Engineer'&#125; ** 关键字参数的作用: 它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。 命名关键字参数对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。 仍以person()函数为例，我们希望检查是否有city和job参数：12345678def person(name, age, **kw): if 'city' in kw: # 有city参数 pass if 'job' in kw: # 有job参数 pass print('name:', name, 'age:', age, 'other:', kw) 如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：12def person(name, age, *, city, job): print(name, age, city, job) 和关键字参数*kw不同，命名关键字参数需要一个特殊分隔符 *后面的参数被视为命名关键字参数。调用方式如下：12&gt;&gt;&gt; person('Jack', 24, city='Beijing', job='Engineer')Jack 24 Beijing Engineer 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：12def person(name, age, *args, city, job): print(name, age, args, city, job) 命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错:1234&gt;&gt;&gt; person('Jack', 24, 'Beijing', 'Engineer')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: person() takes 2 positional arguments but 4 were given 由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。 命名关键字参数可以有缺省值，从而简化调用：12def person(name, age, *, city='Beijing', job): print(name, age, city, job) 由于命名关键字参数city具有默认值，调用时，可不传入city参数 * 使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个\作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数：123def person(name, age, city, job): # 缺少 *，city和job被视为位置参数 pass 参数组合在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 比如定义一个函数，包含上述若干种参数：12345def f1(a, b, c=0, *args, **kw): print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)def f2(a, b, c=0, *, d, **kw): print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw) 在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。12345678910&gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b')a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b', x=99)a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;'x': 99&#125;&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = &#123;'ext': None&#125; 最神奇的是通过一个tuple和dict，你也可以调用上述函数：12345678&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = &#123;'d': 99, 'x': '#'&#125;&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = &#123;'d': 99, 'x': '#'&#125;&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = &#123;'d': 88, 'x': '#'&#125;&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = &#123;'x': '#'&#125; 所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。 虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。 递归函数在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。 至于递归,简单来说就是方法内部自己调用自己, 同时也一定有一个结束点. 如果对方法调用栈了解的话,其实是很容易理解方法的调用过程的, 就是从主线程开始调用方法进行不停的压栈和出栈操作. 方法的调入就是将方法压入栈中, 方法的结束就是方法出栈的过程, 这样保证了方法调用的顺序流. 如果跟踪递归的调用情况会发现也是如此, 到最后一定是这个方法最后从栈中弹出回到主线程, 并且结束. 小结Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过args传入：func((1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过kw传入：func({‘a’: 1, ‘b’: 2})。 使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。 以上内容总结自—&gt;廖雪峰的官方网站]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set 和 Map]]></title>
    <url>%2FSet%E5%92%8CMap%2F</url>
    <content type="text"><![CDATA[ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。 Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。实例:12345678910111213141516171819// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三const set = new Set(document.querySelectorAll('div'));set.size // 56// 类似于const set = new Set();document .querySelectorAll('div') .forEach(div =&gt; set.add(div));set.size // 56 Set 实例添加了两个NaN，但是只能加入一个。这表明，在 Set 内部，两个NaN是相等。123456let set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // Set &#123;NaN&#125; 两个对象总是不相等的。由于两个空对象不相等，所以它们被视为两个值。1234567let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。 add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 1234567891011s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false 下面是一个对比，看看在判断是否包括一个键上面，Object结构和Set结构的写法不同。 12345678910111213141516171819// 对象的写法const properties = &#123; 'width': 1, 'height': 1&#125;;if (properties[someName]) &#123; // do something&#125;// Set的写法const properties = new Set();properties.add('width');properties.add('height');if (properties.has(someName)) &#123; // do something&#125; Array.from方法可以将 Set 结构转为数组。这就提供了去除数组重复成员的另一种方法。12345function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] 遍历操作Set 结构的实例有四个遍历方法，可以用于遍历成员。 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。 * （1） keys()，values()，entries() keys方法、values方法、entries方法返回的都是遍历器对象,由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 12345678910111213141516171819202122let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// ["red", "red"]// ["green", "green"]// ["blue", "blue"] 上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。可以省略values方法，直接用for…of循环遍历 Set （2） forEach() Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。forEach方法的参数就是一个处理函数。该函数的参数与数组的forEach一致，依次为键值、键名、集合本身。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。 另外，forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象。 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。 1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Es6</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 基础]]></title>
    <url>%2Fpython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[input() 用于输入print() 用于输出 数据类型: 1、整数 、浮点数 ‘ / ‘ 表示除 得出的结果一定是个浮点型. ‘ // ‘ 表示除 得出的结果一定是整数.(如果是小数会自动取整) ‘ % ‘ 表示除 取余数(自动取得小数点后面的数) 2、字符串(‘’ / “”) 可以使用 ‘ \ ‘ 转义, r&#39;&#39;表示&#39;&#39;内部的字符串默认不转义 &#39;&#39;&#39; line1 &#39;&#39;&#39; 表示多行内容 Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符 `len()` 获取字符串的长度 replace() 替换 Python对bytes类型的数据用带b前缀的单引号或双引号表示. `x = b&apos;ABC&apos;` 要注意区分&apos;ABC&apos;和b&apos;ABC&apos;，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。 以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如： 12345678&gt;&gt;&gt; 'ABC'.encode('ascii')b'ABC'&gt;&gt;&gt; '中文'.encode('utf-8')b'\xe4\xb8\xad\xe6\x96\x87'&gt;&gt;&gt; '中文'.encode('ascii')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128) 如果bytes中包含无法解码的字节，decode()方法会报错 如果bytes中只有一小部分无效的字节，可以传入errors=&apos;ignore&apos;忽略错误的字节 `&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xff&apos;.decode(&apos;utf-8&apos;, errors=&apos;ignore&apos;) &apos;中&apos;` &gt;在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。 占位符 | 替换内容 ------|------ %d | 整数 %f | 浮点数 %s | 字符串 %x | 十六进制整数 另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}…… `hi, {0}, {1}`.format(&apos;cyq&apos;,123) // hi, cyq, 123 3、布尔值(True / False) and、or、not 运算 and 运算是与运算，只有所有都为True，and运算结果才是True or运算是或运算，只要其中有一个为True，or运算结果就是True not运算是非运算，它是一个单目运算符，把True变成False，False变成True 4、空值(None) None不能理解为0，因为0是有意义的，而None是一个特殊的空值 list and tuple list 索引从0开始,直到len(arr) - 1 ,arr[-1] 将获取最后一项, -2 -3 -4 依次倒数获取 向list末尾添加元素 –&gt; append(item)把元素添加到指定的位置 –&gt; insert(i,’item’)删除末尾项 –&gt; pop() ==&gt; 返回删除项删除指定位置的元素 –&gt; pop(i) ==&gt; 返回删除项 另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改 t = (1,2,3,) 没有append() insert() pop() 等方法,其它都一样.t = (1,2,3,[2,2,3,3]) tuple 是不可以变的 但是他里面的 list 可变 条件判断** if … elseelif是else if的缩写.12345678if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数。Python提供了int()函数来完成这件事情. 循环range()函数，可以生成一个整数序列.例如: range(5) 生成0到小于5的整数. // 0,1,2,3,4list()函数可以转换为list.list(range(5)) // [0,1,2,3,4] for … in … while continue break dict12345678910&gt;&gt;&gt; d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;&gt;&gt;&gt; d['Michael']95&gt;&gt;&gt; Jun in d False&gt;&gt;&gt; d.get('Jun')// dict提供的get()方法，如果key不存在，可以返回None// 返回None的时候Python的交互环境不显示结果。 要删除一个key，用pop(key)方法，对应的value也会从dict中删除：12345d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;d.pop('Bob')75&gt;&gt;&gt; d &#123;'Michael': 95, 'Tracy': 85&#125; 和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢；需要占用大量的内存，内存浪费多。 而list相反： 查找和插入的时间随着元素的增加而增加；占用空间小，浪费内存很少。所以，dict是用空间来换取时间的一种方法。 setset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。重复元素在set中自动被过滤：123&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])&gt;&gt;&gt; s&#123;1, 2, 3&#125; 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果通过remove(key)方法可以删除元素set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作:交集 &amp; 并集 |123456&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2&#123;2, 3&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 4&#125;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-字符串方法]]></title>
    <url>%2Fjava-string%2F</url>
    <content type="text"><![CDATA[为了能方便记忆，想看就看。这里记录一下Java的字符串方法。 table th:first-of-type { width: 7%; } table th:nth-of-type(2) { width: 35%; } 序号 方法 描述 1 char charAt(int index) 返回指定索引处的 char 值。 2 int compareTo(Object o) 把这个字符串和另一个对象比较。 3 int compareTo(String anotherString) 按字典顺序比较两个字符串。 4 int compareToIgnoreCase(String str) 按字典顺序比较两个字符串，不考虑大小写。 5 String concat(String str) 将指定字符串连接到此字符串的结尾。 6 boolean contentEquals(StringBuffer sb) 当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。 7 static String copyValueOf(char[] data) 返回指定数组中表示该字符序列的 String。 8 static String copyValueOf(char[] data, int offset, int count) 返回指定数组中表示该字符序列的 String。 9 boolean endsWith(String suffix) 测试此字符串是否以指定的后缀结束。 10 boolean equals(Object anObject) 将此字符串与指定的对象比较。 11 boolean equalsIgnoreCase(String anotherString) 将此 String 与另一个 String 比较，不考虑大小写。 12 byte[] getBytes() 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 13 byte[] getBytes(String charsetName) 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 14 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此字符串复制到目标字符数组。 15 int hashCode() 返回此字符串的哈希码。 16 int indexOf(int ch) 返回指定字符在此字符串中第一次出现处的索引。 17 int indexOf(int ch, int fromIndex) 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 18 int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。 19 int indexOf(String str, int fromIndex) 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 20 String intern() 返回字符串对象的规范化表示形式。 21 int lastIndexOf(int ch) 返回指定字符在此字符串中最后一次出现处的索引。 22 int lastIndexOf(int ch, int fromIndex) 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 23 int lastIndexOf(String str) 返回指定子字符串在此字符串中最右边出现处的索引。 24 int lastIndexOf(String str, int fromIndex) 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 25 int length() 返回此字符串的长度。 26 boolean matches(String regex) 告知此字符串是否匹配给定的正则表达式。 27 boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。 28 boolean regionMatches(int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。 29 String replace(char oldChar, char newChar) 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 30 String replaceAll(String regex, String replacement) 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 31 String replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 32 String[] split(String regex) 根据给定正则表达式的匹配拆分此字符串。 33 String[] split(String regex, int limit) 根据匹配给定的正则表达式来拆分此字符串。 34 boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开始。 35 boolean startsWith(String prefix, int toffset) 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。 36 CharSequence subSequence(int beginIndex, int endIndex) 返回一个新的字符序列，它是此序列的一个子序列。 37 String substring(int beginIndex) 返回一个新的字符串，它是此字符串的一个子字符串。 38 String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串的一个子字符串。 39 char[] toCharArray() 将此字符串转换为一个新的字符数组。 40 String toLowerCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。 41 String toLowerCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。 42 String toString() 返回此对象本身（它已经是一个字符串！）。 43 String toUpperCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。 44 String toUpperCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。 45 String trim() 返回字符串的副本，忽略前导空白和尾部空白。 46 static String valueOf(primitive data type x) 返回给定data type类型x参数的字符串表示形式。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java interface]]></title>
    <url>%2FjavaInterface%2F</url>
    <content type="text"><![CDATA[接口就是个招牌。比如说你今年放假出去杭州旅游，玩了一上午，你也有点饿了，突然看到前面有个店子，上面挂着KFC，然后你就知道今天中饭有着落了。 KFC就是接口(接口文件名)，我们看到了这个接口(接口文件名)，就知道这个店会卖炸鸡腿（接口文件是做什么的）。那么为神马我们要去定义一个接口涅，这个店可以直接卖炸鸡腿啊（直接写实现方法），是的，这个店可以直接卖炸鸡腿，但没有挂KFC的招牌，我们就不能直接简单粗暴的冲进去叫服务员给两个炸鸡腿了。要么，我们就要进去问，你这里卖不卖炸鸡腿啊，卖不卖汉堡啊，卖不卖圣代啊（这就是反射）。 很显然，这样一家家的问实在是非常麻烦（反射性能很差）。 要么，我们就要记住，中山路108号卖炸鸡，黄山路45号卖炸鸡（硬编码），很显然这样我们要记住的很多很多东西（代码量剧增），而且，如果有新的店卖炸鸡腿，我们也不可能知道（不利于扩展）。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Hello Worldjavascript1console.log('hello world') 创建文件 HelloWorld.java(文件名需与类名一致), 代码如下：java12345public class HelloWorld &#123; public static void main(String [] srgs) &#123; System.out.println("hello world") &#125;&#125; 注：String args[] 与 String[] args 都可以执行，但推荐使用 String[] args，这样可以避免歧义和误读 Java中的对象现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。 拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。 对比现实对象和软件对象，它们之间十分相似。 软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。 在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。 Java中的类类可以看成是创建Java对象的模板。通过下面一个简单的类来理解下Java中类的定义：12345678910111213public class Dog&#123; String breed; int age; String color; void barking()&#123; &#125; void hungry()&#123; &#125; void sleeping()&#123; &#125;&#125; 一个类可以包含以下类型变量： 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。 一个类可以拥有多个方法，在上面的例子中：barking()、hungry()和sleeping()都是Dog类的方法。 创建对象对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步： 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时，会调用构造方法初始化对象。下面是一个创建对象的例子：12345678910public class Puppy &#123; public Puppy(String name) &#123; //这个构造器仅有一个参数：name System.out.println("小狗的名字是:" + name); &#125; // 下面的语句将创建一个Puppy对象 public static void main(String [] srgs) &#123; Puppy myPuppy = new Puppy("Dog"); &#125;&#125; 编译并运行上面的程序，会打印出下面的结果：1小狗的名字是 : Dog 在来看下javascript的:123456789function Puppy(name)&#123; this.name = name; this.getName = ()=&gt;&#123; console.log('狗狗的名字是:' + this.name) &#125;&#125;;const Dog = new Puppy('狗狗');Dog.getName() // 狗狗的名字是: 狗狗 访问实例变量和方法通过已创建的对象来访问成员变量和成员方法，如下所示：123456/* 实例化对象 */ObjectReference = new Constructor();/* 访问类中的变量 */ObjectReference.variableName;/* 访问类中的方法 */ObjectReference.MethodName(); 实例下面的例子展示如何访问实例变量和调用成员方法：123456789101112131415161718192021222324252627public class Puppy&#123; int puppyAge; public Puppy(String name)&#123; // 这个构造器仅有一个参数：name System.out.println("小狗的名字是 : " + name ); &#125; public void setAge( int age )&#123; puppyAge = age; &#125; public int getAge( )&#123; System.out.println("小狗的年龄为 : " + puppyAge ); return puppyAge; &#125; public static void main(String []args)&#123; /* 创建对象 */ Puppy myPuppy = new Puppy( "tommy" ); /* 通过方法来设定age */ myPuppy.setAge( 2 ); /* 调用另一个方法获取age */ myPuppy.getAge( ); /*你也可以像下面这样访问成员变量 */ System.out.println("变量值 : " + myPuppy.puppyAge ); &#125;&#125; 编译并运行上面的程序，产生如下结果：123小狗的名字是 : tommy小狗的年龄为 : 2变量值 : 2 Java 基本数据类型 Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 byte byte 数据类型是8位、有符号的，以二进制补码表示的整数； 最小值是 -128（-2^7）； 最大值是 127（2^7-1）； byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一； 例子：byte a = 100，byte b = -50。 short short 数据类型是 16 位、有符号的以二进制补码表示的整数 最小值是 -32768（-2^15）； 最大值是 32767（2^15 - 1）； Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一； int int 数据类型是32位、有符号的以二进制补码表示的整数； 最小值是 -2,147,483,648（-2^31）； 最大值是 2,147,483,647（2^31 - 1）； 一般地整型变量默认为 int 类型； 例子：int a = 100000, int b = -200000。 long long 数据类型是 64 位、有符号的以二进制补码表示的整数； 最小值是 -9,223,372,036,854,775,808（-2^63）； 最大值是 9,223,372,036,854,775,807（2^63 -1）； 这种类型主要使用在需要比较大整数的系统上； 例子： long a = 100000L，Long b = -200000L。 “L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。 float： float 数据类型是单精度、32位、符合IEEE 754标准的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 默认值是 0.0f； 浮点数不能用来表示精确的值，如货币； 例子：float f1 = 234.5f。 double： double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数； 浮点数的默认类型为double类型； double类型同样不能表示精确的值，如货币； 默认值是 0.0d； 例子：double d1 = 123.4。 boolean： boolean数据类型表示一位的信息； 只有两个取值：true 和 false； 这种类型只作为一种标志来记录 true/false 情况； 默认值是 false； 例子：boolean one = true。 char： har类型是一个单一的 16 位 Unicode 字符； 最小值是 \u0000（即为0）； 最大值是 \uffff（即为65,535）； char 数据类型可以储存任何字符； 例子：char letter = ‘A’;。 对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。12int.MIN_VALUE //最小值int.MAX_VALUE //最大值 强制类型转换 条件是转换的数据类型必须是兼容的。 格式：(type)value type是要强制类型转换后的数据类型 实例： 实例1234567public class QiangZhiZhuanHuan&#123; public static void main(String[] args)&#123; int i1 = 123; byte b = (byte)i1;//强制类型转换为byte System.out.println("int强制类型转换为byte后的值等于"+b); &#125;&#125; 运行结果：1int强制类型转换为byte后的值等于123 自动类型转换 整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。 转换从低级到高级。123低 ------------------------------------&gt; 高byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 数据类型转换必须满足如下规则： 不能对boolean类型进行类型转换。 不能把对象类型转换成不相关类的对象。 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。 转换过程中可能导致溢出或损失精度，例如： 123int i =128; byte b = (byte)i;因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如： 12(int)23.7 == 23; (int)-45.89f == -45 Java 常量常量在程序运行时是不能被修改的。 在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似： final double PI = 3.1415927;虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。 实例变量 实例变量声明在一个类中，但在方法、构造方法和语句块之外； 当一个对象被实例化之后，每个实例变量的值就跟着确定； 实例变量在对象创建的时候创建，在对象被销毁的时候销毁； 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息； 实例变量可以声明在使用前或者使用后； 访问修饰符可以修饰实例变量； 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定； 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。 实例 1234567891011121314151617181920212223242526import java.io.*;public class Employee&#123; // 这个实例变量对子类可见 public String name; // 私有变量，仅在该类可见 private double salary; //在构造器中对name赋值 public Employee (String empName)&#123; name = empName; &#125; //设定salary的值 public void setSalary(double empSal)&#123; salary = empSal; &#125; // 打印信息 public void printEmp()&#123; System.out.println("名字 : " + name ); System.out.println("薪水 : " + salary); &#125; public static void main(String args[])&#123; Employee empOne = new Employee("RUNOOB"); empOne.setSalary(1000); empOne.printEmp(); &#125;&#125; 以上实例编译运行结果如下:1234$ javac Employee.java $ java Employee名字 : RUNOOB薪水 : 1000.0 类变量（静态变量） 类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。 静态变量在程序开始时创建，在程序结束时销毁。 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 静态变量可以通过：ClassName.VariableName的方式访问。 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。 123456789101112import java.io.*; public class Employee &#123; //salary是静态的私有变量 private static double salary; // DEPARTMENT是一个常量 public static final String DEPARTMENT = "开发人员"; public static void main(String args[])&#123; salary = 10000; System.out.println(DEPARTMENT+"平均工资:"+salary); &#125;&#125; 访问控制修饰符Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）public : 对所有类可见。使用对象：类、接口、变量、方法protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 访问控制和继承请注意以下方法继承的规则：父类中声明为 public 的方法在子类中也必须为 public。父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。父类中声明为 private 的方法，不能够被继承。 非访问修饰符static 修饰符 静态变量： static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。 静态方法： static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 final 修饰符 final 变量： final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。 final 修饰符通常和 static 修饰符一起使用来创建类常量。 final 方法: 类中的 final 方法可以被子类继承，但是不能被子类修改。声明 final 方法的主要目的是防止该方法的内容被修改。 final 类 final 类不能被继承，没有类能够继承 final 类的任何特性。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack 使用/配置]]></title>
    <url>%2Fwebpace-4%2F</url>
    <content type="text"><![CDATA[从零开始配置 Webpack； 在实际项目开发中，零配置是不存在的。新建一个webpa文件夹， 初始化改文件夹1npm init 目的是生成 package.json 文件. 安装最新版本或特定版本的webpack 12npm install --save-dev webpacknpm install --save-dev webpack@&lt;version&gt; 安装webpack-cli; 这里要全局安装，否者会出一个非法命令1npm i -g webpack-cli --save-dev 是指在package.json里面生成安装的webpack等插件的版本信息好了顺利的话已经可以使用了. 在webp文件夹内新建src/index.js1document.write('hello webpack4!') 命令行输入：1webpack --mode=development 成功后显示，打开 dist 文件夹会看到 main.js (默认输出到 dist)12345678Hash: f1dff803bf82cb639132Version: webpack 4.17.1Time: 135msBuilt at: 2018-08-29 20:42:46 Asset Size Chunks Chunk Namesmain.js 3.8 KiB main [emitted] mainEntrypoint main = main.js[./src/index.js] 34 bytes &#123;main&#125; [built] –mode 模式 (必选，不然会有 WARNING)，是 webpack4 新增的参数选项，默认是 production –mode production 生产环境 提供 uglifyjs-webpack-plugin 代码压缩 不需要定义 new webpack.DefinePlugin({ “process.env.NODE_ENV”: JSON.stringify(“production”) }) 默认 production 默认开启 NoEmitOnErrorsPlugin -&gt; optimization.noEmitOnErrors, 编译出错时跳过输出，以确保输出资源不包含错误 默认开启 ModuleConcatenationPlugin -&gt; optimization.concatenateModules, webpack3 添加的作用域提升(Scope Hoisting) –mode development 开发环境 使用 eval 构建 module, 提升增量构建速度 不需要定义 new webpack.DefinePlugin({ “process.env.NODE_ENV”: JSON.stringify(“development”) }) 默认 development 默认开启 NamedModulesPlugin -&gt; optimization.namedModules 使用模块热替换(HMR)时会显示模块的相对路径 接下来创建 dist/index.html 并引入 main.js, 浏览器中打开看内容。12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;webpack-simple&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript" src="./main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 再创建一个文件 src/content.js, 在 src/index.js 中引入该模块12// content.jsmodule.exports = 'Looooooooooooooong content!'; 12// index.jsdocument.write(`Hello webpack4!$&#123;require('./content.js')&#125;`); 再次执行 webpack –mode=development 完了打开 index.html12// 内容Hello webpack4!Looooooooooooooong content!]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex兼容处理]]></title>
    <url>%2Fflex%2F</url>
    <content type="text"><![CDATA[css样式 flex：定义布局为盒模型 flex-v：盒模型垂直布局 flex-1：子元素占据剩余的空间 flex-align-center：子元素垂直居中 flex-pack-center：子元素水平居中 flex-pack-justify：子元素两端对齐 1234567891011121314151617181920212223242526272829303132333435363738394041.flex &#123; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex;&#125;.flex-v &#123; -webkit-box-orient: vertical; -webkit-flex-direction: column; -ms-flex-direction: column; flex-direction: column;&#125;.flex-1 &#123; -webkit-box-flex: 1; -webkit-flex: 1; -ms-flex: 1; flex: 1;&#125;.flex-align-center &#123; -webkit-box-align: center; -webkit-align-items: center; -ms-flex-align: center; align-items: center;&#125;.flex-pack-center &#123; -webkit-box-pack: center; -webkit-justify-content: center; -ms-flex-pack: center; justify-content: center;&#125;.flex-pack-justify &#123; -webkit-box-pack: justify; -webkit-justify-content: space-between; -ms-flex-pack: justify; justify-content: space-between;&#125; 兼容性：ios 4+、android 2.3+、winphone8+ 示例123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt;&lt;meta content="yes" name="apple-mobile-web-app-capable"&gt;&lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt;&lt;meta content="telephone=no" name="format-detection"&gt;&lt;meta content="email=no" name="format-detection"&gt;&lt;style type="text/css"&gt;.flex&#123;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;&#125;.flex-v&#123;-webkit-box-orient:vertical;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;&#125;.flex-1&#123;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;&#125;.flex-align-center&#123;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;&#125;.flex-pack-center&#123;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;&#125;.flex-pack-justify&#123;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="flex flex-pack-justify"&gt; &lt;div&gt;模块一&lt;/div&gt; &lt;div&gt;模块二&lt;/div&gt; &lt;div&gt;模块三&lt;/div&gt; &lt;div&gt;模块四&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布局]]></title>
    <url>%2F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[左侧固定宽度,右侧自适应.方案一:123456789101112131415161718192021&lt;style&gt; *&#123; margin: 0;padding: 0; &#125; .left , .main &#123; height: 165px; &#125; .left &#123; float: left;width: 200px;background: red; &#125; .main &#123; padding-left: 200px;background: blue; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="con"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="main"&gt;main&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 方案二:123456789101112131415161718192021222324252627&lt;style&gt; *&#123; margin: 0;padding: 0; &#125; .con &#123; position: relative; &#125; .left , .main &#123; top: 0; height: 165px; &#125; .left &#123; position: absolute; left: 0; width: 200px; background: red; &#125; .main &#123; padding-left: 200px; background: blue; &#125;&lt;/style&gt;&lt;div class="con"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="main"&gt;main&lt;/div&gt;&lt;/div&gt; 两侧固定宽度,中间自适应. 1234567891011121314151617181920212223242526272829303132&lt;style&gt; *&#123; margin: 0;padding: 0; &#125; .con&#123; overflow: hidden &#125; .left , .main ,.right&#123; height: 165px; &#125; .left &#123; width: 200px; background: red; float: left; &#125; .right &#123; width: 200px; background: red; float: right; &#125; .main &#123; background: blue; width: 100%; padding: 0 200px; &#125;&lt;/style&gt;&lt;div class="con"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt; &lt;div class="main"&gt;main&lt;/div&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js 基础算法]]></title>
    <url>%2FJs-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 返回字符串中字符出现次数最多的那字符123456789101112131415161718192021222324252627var str = 'tecasdasdsfgjoertioerldgibidflksdsssssllllldnwekroiwrdslfashnology'; String.prototype.maxnum = function () &#123; if(this.length &lt;= 1) &#123; return this &#125;; let arr = this.split(''); let josn = &#123;&#125;; for(let i = 0, L = this.length; i &lt; L; i++)&#123; if(!josn[arr[i]])&#123; josn[arr[i]] = 1 &#125; else &#123; josn[arr[i]] += 1 &#125; &#125; let num = 0; let wrop = ''; for (let item in josn) &#123; if(josn[item] &gt; num) &#123; num = josn[item]; wrop = item; &#125; &#125; return wrop; &#125; console.log(str.maxnum()) 2. 不借助第三变量, 交换值. 12345678function swop (a, b) &#123; a = a - b; b = a + b; a = b - a; return [a, b]&#125;console.log(45, 68)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重(2)]]></title>
    <url>%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D(es6%2Bes5)%2F</url>
    <content type="text"><![CDATA[1. 利用一个json对象原理: 循环数组里面的每一项设置为json的key, value为 1.1234567891011121314Array.prototype.removal_one = function () &#123; let jsn = &#123;&#125;, arr1 = [], len = this.length; for (let i = 0; i &lt; len; i++) &#123; const item = this[i] if (!jsn[item]) &#123; jsn[item] = 1; arr1.push(item); &#125; &#125; return arr1; &#125; 2. 利用 indexOf()原理: 在新数组里查找旧数组的每一项,没有就添加进来.12345678910Array.prototype.removal_two = function () &#123; let arr1 = []; let len = this.length; for (let i = 0; i &lt; len; i++) &#123; if (arr1.indexOf(this[i]) == -1) &#123; arr1.push(this[i]); &#125; &#125; return arr1;&#125; 3. 利用 indexOf()原理: 同 2.123456789Array.prototype.removal_three = function () &#123; let arr1 = []; this.map((x) =&gt; &#123; if (arr1.indexOf(x) == -1) &#123; arr1.push(x) &#125; &#125;) return arr1;&#125; 4. 还是利用 indexOf() (原理有差别)原理: 查找数组里面的每一项,看其下标是否对应.12345678910111213141516171819202122232425262728293031323334353637383940 Array.prototype.removal_four = function () &#123; let arr1 = []; this.reduce((prev, now, index, arr) =&gt; &#123; if( arr.indexOf(now) == index ) &#123; arr1.push( now ) &#125; &#125;,this[0]) return arr1; &#125; //reduce() ES6新增方法. 二个参数: //第一个参数接收一个函数 其接收四个参数: // 第一个参数(prev) =&gt; 前一个值 // 第二个参数(now) =&gt; 当前值 // 第三个参数(index) =&gt; 当前值的索引 // 第四个参数(arr) =&gt; 当前值的数组 //第二个参数接收一个默认值,对应prev(起始值)// 不接收第二个参数 var arr = [1,2,3,4,5,6]; arr.reduce((prev, now, index, arr)=&gt;&#123; console.log(prev,now) &#125;) //1 2 //undefined 3 //undefined 4 //undefined 5 //undefined 6 // 接收第二个参数 var arr1 = [1,2,3,4,5,6]; arr.reduce((prev, now, index, arr)=&gt;&#123; console.log(prev,now) &#125;,0) //0 1 //undefined 3 //undefined 4 //undefined 5 //undefined 6 5. ES6 set() 12let arr1 = [1,2,3,1,2,6,4,8,4,5,6];let arr = new set(arr1)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包可以用在许多地方。它的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 请看下面的代码。 123456789101112131415161718192021 function f1()&#123; var num = 99; add = function () &#123; num++ &#125; // 这里没有使用 var add被注册为全局变量 function f2() &#123; alert(num); // 调用父函数变量 num &#125; return f2; &#125; var result = f1(); // f1返回f2函数, f2被赋给了一个全局变量，这导致f2始终在内存中 result(); // 99 add(); // num++ result(); // 100 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是99，第二次的值是100。这证明了，函数f1中的局部变量num一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是add=function(){num+=1}这一行，首先在add前面没有使用var关键字，因此add是一个全局变量，而不是局部变量。其次，add的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以add相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript 闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无具体宽高元素水平垂直居中]]></title>
    <url>%2Fcss-center%2F</url>
    <content type="text"><![CDATA[居中效果在CSS中很是普通的效果，平时大家所看到的居中效果主要分为三大类：水平居中、垂直居中和水平垂直居中。而其中水平居中相对于后两者来说要简单得. 水平居中 1. 浮动 12345678910&lt;style media="screen" type="text/css"&gt; .wrap&#123;position:relative;left:50%; float:left;&#125; .cont&#123;position:relative;left:-50%;&#125;&lt;/style&gt;&lt;div class="wrap"&gt; &lt;div class="cont"&gt; 没有宽度的div实现水平居中显示 &lt;/div&gt;&lt;/div&gt; 原理:先让元素左浮动 父元素的左边距页面的左边为0,设置父元素的position:relative;left:50%;后 父元素的左边距页面的左边为50%.此时子元素的左边距页面的左边也是50%, 这时如果设置子元素的position:relative;left:-50%; 或者 position:relative;right:50%;子元素都会像左边移动50%的距离.(此时的50%是页面的25%) 2. 定位 12345678910111213&lt;style media="screen" type="text/css"&gt; .con &#123;position: relative;&#125; .wrap&#123;position: absolute;left:50%;&#125; .cont&#123;position: relative;left:-50%;&#125;&lt;/style&gt;&lt;div class="con"&gt; &lt;div class="wrap"&gt; &lt;div class="cont"&gt; 没有宽度的div实现水平居中显示 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 原理: 与方法1 一样 3. display: box 12345678910111213141516171819202122&lt;style media="screen" type="text/css"&gt; .cont &#123; display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-pack: center; display: -moz-box; -moz-box-orient: horizontal; -moz-box-pack: center; display: -o-box; -o-box-orient: horizontal; -o-box-pack: center; display: -ms-box; -ms-box-orient: horizontal; -ms-box-pack: center; display: box; box-orient: horizontal; box-pack: center; &#125;&lt;/style&gt;&lt;div class="cont"&gt; 没有宽度的div实现水平居中显示&lt;/div&gt; 4. fit-content 12345678910111213&lt;style media="screen" type="text/css"&gt; .cont&#123; width: -moz-fit-content; width:-webkit-fit-content; width: fit-content; margin-left: auto; margin-right: auto; &#125;&lt;/style&gt;&lt;div class="cont"&gt; 没有宽度的div实现水平居中显示&lt;/div&gt; 5. display: table 12345678910&lt;style media="screen" type="text/css"&gt; .cont&#123; display: table; margin: auto; &#125;&lt;/style&gt;&lt;div class="cont"&gt; 没有宽度的div实现水平居中显示&lt;/div&gt; 垂直居中 1. 方法一 12345678910111213141516.cont &#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; height: 220px; width: 70%; background: red;&#125;&lt;div class="cont"&gt; 垂直居中显示 需要设置宽度,高度&lt;/div&gt; 2. 方法二 12345678910111213.cont &#123; width: 70%; height: 200px; position: absolute; top: 50%; margin-top: -100px; background: red;&#125;&lt;div class="cont"&gt; 垂直居中显示 需要设置宽度,高度&lt;/div&gt; 3. 方法三 12345678910.cont &#123; position: absolute; top:50%; transform:translateY(-50%);&#125;&lt;div class="cont"&gt; 垂直居中显示 无需宽高 &lt;/div&gt; 4. 方法四 123456789101112.wrap&#123; display: flex; align-items:center;&#125;.cont&#123;margin: auto;&#125;&lt;div class="wrap"&gt; &lt;div class="cont"&gt; 没有宽度 &lt;/div&gt;&lt;/div&gt; 水平垂直居中 1. 方法一 1234567891011121314.cont &#123; width: 50%; height: 50%; background: #000; /* overflow: auto; */ margin: auto; position: absolute; top: 0; left: 0; bottom: 0; right: 0; &#125;&lt;div class="cont"&gt; 垂直居中显示 需宽高&lt;/div&gt; 2. 方法二 1234567891011.cont &#123; position: absolute; top:50%; left:50%; transform:translate(-50%,-50%);&#125;&lt;div class="cont"&gt; 垂直居中显示 无需宽高 &lt;/div&gt;]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node(express) + mysql 实现模糊查询]]></title>
    <url>%2Fnode-mysql%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[Node + express + mysql + Navicat for mysql 实现模糊查询 仓库地址 -&gt; 点击这里 话不多说直接上代码..app.js12345678910111213141516171819202122232425262728293031323334353637383940const express = require('express');// const bodyparser = require('body-parser');const mysql = require('mysql');const app = express();const router = express.Router();app.use(express.urlencoded(&#123;&#125;));let pool = mysql.createPool(&#123; host:'localhost', user:'root', password:'root', database:'query', port:3306&#125;)// 设置为可跨域app.all('*', function(req, res, next) &#123; res.header("Access-Control-Allow-Origin", "*"); res.header("Access-Control-Allow-Headers", "X-Requested-With"); res.header("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS"); res.header("X-Powered-By",' 3.2.1') res.header("Content-Type", "application/json;charset=utf-8"); next();&#125;);//这里是 /login 前端请求地址为 http://localhost:8001/loginapp.get('/login',(req,res)=&gt;&#123; var value = req.query.val; pool.query(`SELECT * FROM students where name like '%$&#123;value&#125;%'`, (qerr,vals,fields)=&gt;&#123; let rows = JSON.stringify(vals); res.send(rows) &#125;) &#125;)app.use(express.static('./'))app.listen(8001,() =&gt; &#123; console.log('ok');&#125;)]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把 vs Code 添加到右键菜单 ( 其他程序一样 )]]></title>
    <url>%2F%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E8%8F%9C%E5%8D%95%E7%9A%84%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[把 vs Code 添加到右键菜单 (文件或者文件夹的右键打开菜单的显示) 第一种首先 win + R 输入 regedit 回车打开注册表,找到HKEY_CLASSES_ROOT &gt;*&gt;shell / 在shell下新建 项 名字 Open with VS Code 在 Open with VS Code 文件夹下 新建 项 名字为command(必须是这个名字) 例: 点击Open with VS Code 会出现如图右侧 蓝色框内的文字是右击菜单所显示的文字,可更改. 在右侧空白处 右击新建 可扩充字符串值 名字为Icon 数据处写 你自己的路径 + , + 0. 如绿色框… 点击 command , 在右侧右击 ‘默认’ &gt; 修改 数值数据为 &quot;D:\LENOVOE\Microsoft VS Code\Code.exe&quot; &quot;%1&quot; 路径改为自己的路径 以上为右击文件时的菜单及图标 , 下面说下右击文件夹时的菜单. 找到HKEY_CLASSES_ROOT &gt;Directory&gt;shell具体操作同上… 第二种新建文本 把下面代码放进去 改名为 vsCodeOpenFolder.reg . 注: 下面代码需把路径改为自己的路径. 改完后删除 //改完请删掉此注释 一切改完,运行此文件即可.123456789101112131415161718192021222324252627282930Windows Registry Editor Version 5.00 ; Open files [HKEY_CLASSES_ROOT\*\shell\Open with VS Code] @="Edit with VS Code" "Icon"="D:\\LENOVOE\\Microsoft VS Code\\Code.exe",0" //改完请删掉此注释 [HKEY_CLASSES_ROOT\*\shell\Open with VS Code\command] @="\"D:\\LENOVOE\\Microsoft VS Code\\Code.exe\" \"%1\"" //改完请删掉此注释 ; This will make it appear when you right click ON a folder ; The "Icon" line can be removed if you don't want the icon to appear [HKEY_CLASSES_ROOT\Directory\shell\vscode] @="Open Folder as VS Code Project" "Icon"="D:\\LENOVOE\\Microsoft VS Code\\Code.exe",0" //改完请删掉此注释 [HKEY_CLASSES_ROOT\Directory\shell\vscode\command] @="\"D:\\LENOVOE\\Microsoft VS Code\\Code.exe\" \"%1\"" //改完请删掉此注释 ; This will make it appear when you right click INSIDE a folder ; The "Icon" line can be removed if you don't want the icon to appear [HKEY_CLASSES_ROOT\Directory\Background\shell\vscode] @="Open Folder as VS Code Project" "Icon"="D:\\LENOVOE\\Microsoft VS Code\\Code.exe",0" //改完请删掉此注释 [HKEY_CLASSES_ROOT\Directory\Background\shell\vscode\command] @="\"D:\\LENOVOE\\Microsoft VS Code\\Code.exe\" \"%1\"" //改完请删掉此注释]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>杂七杂八</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Small program - config]]></title>
    <url>%2FsmallProgram-config%2F</url>
    <content type="text"><![CDATA[小程序 - 配置 配置app.json文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。 以下是一个包含了所有配置选项的 app.json ：1234567891011121314151617181920212223&#123; "pages": [ "pages/index/index", "pages/logs/index" ], "window": &#123; "navigationBarTitleText": "Demo" &#125;, "tabBar": &#123; "list": [&#123; "pagePath": "pages/index/index", "text": "首页" &#125;, &#123; "pagePath": "pages/logs/logs", "text": "日志" &#125;] &#125;, "networkTimeout": &#123; "request": 10000, "downloadFile": 10000 &#125;, "debug": true&#125; app.json 配置项列表 属性 类型 必填 描述 pages String Array 是 设置页面路径 window Object 否 设置默认页面的窗口表现 tabBar Object 否 设置底部 tab 的表现 networkTimeout Object 否 设置网络超时时间 debug String Array 否 设置是否开启 debug 模式 pages接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息， 数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改 文件名不需要写文件后缀，因为框架会自动去寻找路径下 .json, .js, .wxml, .wxss 四个文件进行整合。 如开发目录为： pages/ index/ index.wxml index.js index.wxss logs/ logs.wxml logs.js app.jsapp.jsonapp.wxss 则需要在 app.json 中写123456&#123; "pages":[ "pages/index/index", "pages/logs/logs" ]&#125; window用于设置小程序的状态栏、导航条、标题、窗口背景色。 属性 类型 默认值 描述 最低版本 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如”#000000” navigationBarTextStyle String white 导航栏标题颜色，仅支持 black/white navigationBarTitleText String 导航栏标题文字内容 navigationStyle String default 导航栏样式，仅支持 default/custom。custom 模式可自定义导航栏，只保留右上角胶囊状的按钮 微信版本 6.6.0 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉 loading 的样式，仅支持 dark/light backgroundColorTop String #ffffff 顶部窗口的背景色，仅 iOS 支持 微信版本 6.5.16 backgroundColorBottom String #ffffff 底部窗口的背景色，仅 iOS 支持 微信版本 6.5.16 enablePullDownRefresh Boolean false 是否开启下拉刷新，详见页面相关事件处理函数 onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px 注：HexColor（十六进制颜色值），如”#ff00ff” 注：navigationStyle 只在 app.json 中生效。开启 custom 后，低版本客户端需要做好兼容。开发者工具基础库版本切到 1.7.0（不代表最低版本，只供调试用） 可方便切到旧视觉 如 app.json ：123456789&#123; "window":&#123; "navigationBarBackgroundColor": "#ffffff", "navigationBarTextStyle": "black", "navigationBarTitleText": "微信接口功能演示", "backgroundColor": "#eeeeee", "backgroundTextStyle": "light" &#125;&#125; tabBar如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面 Tip： 当设置 position 为 top 时，将不会显示 icon tabBar 中的 list 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。 属性说明： 属性 类型 必填 默认值 描述 color HexColor 是 tab 上的文字默认颜色 selectedColor HexColor 是 tab 上的文字选中时的颜色 backgroundColor HexColor 是 tab 的背景色 borderStyle String 否 black tabbar上边框的颜色， 仅支持 black/white list Array 是 tab 的列表，详见 list 属性说明，最少2个、最多5个 tab position String 否 bottom 可选值 bottom、top 其中 list 接受一个数组，数组中的每个项都是一个对象，其属性值如下： 属性 类型 必填 说明 pagePath String 是 页面路径，必须在 pages 中先定义 text String 是 tab 上按钮文字 iconPath String 否 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效，不支持网络图片 selectedIconPath String 否 选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效 networkTimeout可以设置各种网络请求的超时时间。 属性说明: 属性 类型 必填 说明 request Number 否 wx.request的超时时间，单位毫秒，默认为：60000 connectSocket Number 否 wx.connectSocket的超时时间，单位毫秒，默认为：60000 uploadFile Number 否 wx.uploadFile的超时时间，单位毫秒，默认为：60000 downloadFile Number 否 wx.downloadFile的超时时间，单位毫秒，默认为：60000 debug可以在开发者工具中开启 debug 模式，在开发者工具的控制台面板，调试信息以 info 的形式给出，其信息有Page的注册， 页面路由， 数据更新， 事件触发。 可以帮助开发者快速定位一些常见的问题。 page.json每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。 页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个键，如： 属性 类型 默认值 描述 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如”#000000” navigationBarTextStyle String white 导航栏标题颜色，仅支持 black/white navigationBarTitleText String 导航栏标题文字内容 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉 loading 的样式，仅支持 dark/light enablePullDownRefresh Boolean false 是否开启下拉刷新，详见页面相关事件处理函数。 disableScroll Boolean false 设置为 true 则页面整体不能上下滚动；只在 page.json 中有效，无法在 app.json 中设置该项 onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px 1234567&#123; "navigationBarBackgroundColor": "#ffffff", "navigationBarTextStyle": "black", "navigationBarTitleText": "微信接口功能演示", "backgroundColor": "#eeeeee", "backgroundTextStyle": "light"&#125;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[router-beforeEach]]></title>
    <url>%2Fvue-router-beforeach%2F</url>
    <content type="text"><![CDATA[vue-router (导航守卫)vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。 记住 参数或查询的改变并不会触发进入/离开的导航守卫。 你可以通过观察 $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫。 全局守卫使用 router.beforeEach 注册一个全局前置守卫：1234const router = new VueRouter(&#123;...&#125;)router.beforeEach((to, from, next)=&gt;&#123; //...&#125;) 当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中。每个守卫方法接收三个参数： to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。 next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。 next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。 next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。 确保要调用 next 方法，否则钩子就不会被 resolved。 全局解析守卫在 2.5.0+ 你可以用 router.beforeResolve 注册一个全局守卫。这和 router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。 全局后置钩子你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：123router.afterEach((to, from) =&gt; &#123; // ...&#125;) 路由独享的守卫你可以在路由配置上直接定义 beforeEnter 守卫：1234567891011const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;) 这些守卫与全局前置守卫的方法参数是一样的。 组件内的守卫最后，你可以在路由组件内直接定义以下路由导航守卫： beforeRouteEnter beforeRouteUpdate (2.2 新增) beforeRouteLeave 123456789101112131415161718const Foo = &#123; template: `...`, beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 &#125;, beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125;&#125; beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。 12345beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; // 通过 `vm` 访问组件实例 &#125;)&#125; 注意 beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。 12345beforeRouteUpdate (to, from, next) &#123; // just use `this` this.name = to.params.name next()&#125; 这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。12345678beforeRouteLeave (to, from , next) &#123; const answer = window.confirm('Do you really want to leave? you have unsaved changes!') if (answer) &#123; next() &#125; else &#123; next(false) &#125;&#125; 完整的导航解析流程 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node 获取req参数]]></title>
    <url>%2Fnode-%E8%8E%B7%E5%8F%96req%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[获取request参数的四种方法: req.body 解析body不是nodejs默认提供的，你需要载入body-parser中间件才可以使用req.body 此方法通常用来解析POST请求中的数据 req.query 由nodejs默认提供，无需载入中间件 此方法多适用于GET请求，解析GET里的参数 req.params nodejs默认提供，无需载入其他中间件 多适用于restful风格url中的参数的解析。 req.query与req.params的区别 req.params包含路由参数（在URL的路径部分），而req.query包含URL的查询参数（在URL的？后的参数）。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node+mySQL接口]]></title>
    <url>%2Fnode-mySQL%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[数据库Navicat for mysql 建表写入数据 node.jsapp.js12345678910111213141516171819202122232425262728293031323334const express = require('express');const mysql = require('mysql');const app = express();//建立连接const pool = mysql.createPool(&#123; host:'localhost', user:'root', password:'123456', database:'dataBaseName', port:3306&#125;)// 设置为可跨域app.all('*', function(req, res, next) &#123; res.header("Access-Control-Allow-Origin", "*"); res.header("Access-Control-Allow-Headers", "X-Requested-With"); res.header("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS"); res.header("X-Powered-By",' 3.2.1') res.header("Content-Type", "application/json;charset=utf-8"); next();&#125;);// 前端请求地址为 http://localhost:8001/loginapp.get('/login',(req,res)=&gt;&#123; pool.query(`SELECT * FROM login`, (qerr,vals,fields)=&gt;&#123; let rows = JSON.stringify(vals); res.send(rows) &#125;) &#125;)app.listen(8001,() =&gt; &#123; console.log('ok');&#125;)]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$().each() 与 $.each() 区别]]></title>
    <url>%2Feach-each%2F</url>
    <content type="text"><![CDATA[$().each()1234$('input[type = "text"]').each((idx,ite)=&gt;&#123; console.log(idx,ite)&#125;)//第一个参数是索引,第二个参数是当前dom元素 $.each()遍历数组12345678910111213var json = [&#123; name: "John", lang: "JS" &#125;,&#123; name: "boy", lang: "html" &#125;,&#123; name: "job", lang: "css" &#125;];$.each(json,(idx,ite)=&gt;&#123; console.log(idx,ite) console.log('name:'+ite['name'] + '; lang:' + ite['lang'])&#125;)//输出//0 &#123;name: "John", lang: "JS"&#125;//name:John; lang:JS//1 &#123;name: "boy", lang: "html"&#125;//name:boy; lang:html//2 &#123;name: "job", lang: "css"&#125;//name:job; lang:css 遍历对象12345678var json = &#123; name: "John", lang: "JS" &#125;; $.each(json,(idx,ite)=&gt;&#123; console.log('key:' + idx ,'value:' + ite) &#125;) //输出 // key:name value:John // key:lang value:JS]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object.entries() and Object.values()]]></title>
    <url>%2Fes7%2F</url>
    <content type="text"><![CDATA[Object.entries(); 如果一个对象是具有键值对的数据结构，则每一个键值对都将会编译成一个具有两个元素的数组，这些数组最终会放到一个数组中，返回一个二维数组。 简言之，该方法会将某个对象的可枚举属性与值按照二维数组的方式返回。若目标对象是数组时，则会将数组的下标作为键值返回。例如：123Object.entries(&#123; one: 1, two: 2 &#125;) //[['one', 1], ['two', 2]]Object.entries([1, 2]) //[['0', 1], ['1', 2]] Object.entries()返回的数组的顺序与for-in循环保持一致，即如果对象的key值是数字，则返回值会对key值进行排序，返回的是排序后的结果。例如：1Object.entries(&#123; 3: 'a', 4: 'b', 1: 'c' &#125;) //[['1', 'c'], ['3', 'a'], ['4', 'b']] 使用Object.entries()，我们还可以进行对象属性的遍历。例如：12345678let obj = &#123; one: 1, two: 2 &#125;;for (let [k,v] of Object.entries(obj)) &#123; console.log(`$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;`);&#125;//输出结果如下：'one': 1'two': 2 Object.values()它的工作原理跟Object.entries()很像，顾名思义，它只返回自己的键值对中属性的值。它返回的数组顺序，也跟Object.entries()保持一致。 12Object.values(&#123; one: 1, two: 2 &#125;) //[1, 2]Object.values(&#123; 3: 'a', 4: 'b', 1: 'c' &#125;) //['c', 'a', 'b']]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES7 ES8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[attr prop 区别]]></title>
    <url>%2FattrAndProp%2F</url>
    <content type="text"><![CDATA[jquery中attr和prop的区别 在高版本的jquery引入prop方法后，什么时候该用prop？什么时候用attr？它们两个之间有什么区别？这些问题就出现了。 对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。 举几个例子就知道了。 1&lt;a href="http://www.baidu.com" target="_self" class="btn"&gt;百度&lt;/a&gt; 这个例子里&lt;a&gt;元素的DOM属性有“href、target和class“，这些属性就是&lt;a&gt;元素本身就带有的属性，也是W3C标准里就包含有这几个属性，或者说在IDE里能够智能提示出的属性，这些就叫做固有属性。处理这些属性时，建议使用prop方法。 1&lt;a href="#" id="link1" action="delete"&gt;删除&lt;/a&gt; 这个例子里&lt;a&gt;元素的DOM属性有“href、id和action”，很明显，前两个是固有属性，而后面一个“action”属性是我们自己自定义上去的，&lt;a&gt;元素本身是没有这个属性的。这种就是自定义的DOM属性。处理这些属性时，建议使用attr方法。使用prop方法取值和设置属性值时，都会返回undefined值。 再举一个例子： 12&lt;input id="chk1" type="checkbox" /&gt; //是否可见&lt;input id="chk2" type="checkbox" checked="checked" /&gt; //是否可见 像checkbox，radio和select这样的元素，选中属性对应“checked”和“selected”，这些也属于固有属性，因此需要使用prop方法去操作才能获得正确的结果。 12$("#chk1").prop("checked") == false$("#chk2").prop("checked") == true 如果上面使用attr方法，则会出现： 12$("#chk1").attr("checked") == undefined$("#chk2").attr("checked") == "checked"]]></content>
      <categories>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 跨域]]></title>
    <url>%2FkuaYu%2F</url>
    <content type="text"><![CDATA[首先要知道什么是跨域！ 跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。 所谓同源是指，域名，协议，端口均相同，不明白没关系，举个栗子： 123456789101112http://www.123.com/index.html 调用 http://www.123.com/server.php （非跨域）http://www.123.com/index.html 调用 http://www.456.com/server.php （主域名不同:123/456，跨域）http://abc.123.com/index.html 调用 http://def.123.com/server.php （子域名不同:abc/def，跨域）http://www.123.com:8080/index.html 调用 http://www.123.com:8081/server.php （端口不同:8080/8081，跨域）http://www.123.com/index.html 调用 https://www.123.com/server.php （协议不同:http/https，跨域）请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。 浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。 使用JSONP进行跨域请求！1234567var script = document.createElement("script");script.src = "https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse";document.body.insertBefore(script, document.body.firstChild);function handleResponse(response)&#123; // 对response数据进行操作代码 console.log(response)&#125; jsonp原理：其本质是利用了标签的src属性具有可跨域的特性，由服务端返回预先定义好的javascript函数的调用，并且将服务端数据以该函数参数的形式传递过来。 使用JQuery $.ajax()进行请求12345678910111213141516$.ajax(&#123; async : true, url : "https://api.douban.com/v2/book/search", type : "GET", dataType : "jsonp", // 返回的数据类型，设置为JSONP方式 jsonp : 'callback', //指定一个查询参数名称来覆盖默认的 jsonp 回调参数名 callback jsonpCallback: 'handleResponse', //设置回调函数名 data : &#123; q : "javascript", count : 1 &#125;, success: function(response, status, xhr)&#123; console.log('状态为：' + status + ',状态是：' + xhr.statusText); console.log(response); &#125;&#125;); 使用 $.getJSON()进行请求在路径后加 ‘？callback=？’ 即可123$.getJSON("https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=?", function(data)&#123; console.log(data);&#125;); ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加标签来调用服务器提供的js脚本。 ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。 *本文参考https://blog.csdn.net/u014607184/article/details/52027879]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小伙,要加油哦~]]></title>
    <url>%2F%E5%B0%8F%E4%BC%99-%E8%A6%81%E5%8A%A0%E6%B2%B9%E5%93%A6%2F</url>
    <content type="text"><![CDATA[I shut my eyes and tried to go to sleep.]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重]]></title>
    <url>%2Fone%2F</url>
    <content type="text"><![CDATA[Array 1.思想:遍历元素组,建立新数组。利用indexOf判断新数组中是否存在原数组中的第i项,不存在便添加进去。ps:这里可以封装函数12345678var arr = [12, 5, 8, 12, 6, 4, 8, 5, 3], arr2 = []; for (let i = 0, j = arr.length; i &lt; j; i++) &#123; if (arr2.indexOf(arr[i]) === -1) &#123; arr2.push(arr[i]) &#125; &#125; console.log(arr2) // [12,5,8,6,4,3] 2.思想:利用indexOf判断数组中第i项的索引值是否等于其索引.(细细想想indexOf的用法及返回值)123456789101112var arr = [12, 5, 8, 12, 6, 4, 8, 5, 3];Array.prototype.removal=function()&#123; let arr = []; for(let i=0,j=this.length;i&lt;j;i++)&#123; if(this.indexOf(this[i]) == i)&#123; arr.push(this[i]) &#125; &#125; return arr&#125;var arr2 = arr.removal()console.log(arr2) // [12,5,8,6,4,3] 3.思想:利用对象的属性不能相同的特点进行去重12345678910111213var arr = [12, 5, 8, 12, 6, 4, 8, 5, 3]; Array.prototype.removal=function()&#123; let obj = &#123;&#125;, result = []; for(let i=0,j=this.length;i&lt;j;i++)&#123; if(!obj[this[i]])&#123; obj[this[i]] = 1; result.push(this[i]) &#125; &#125; return result &#125; console.log(arr.removal()) // [12,5,8,6,4,3] 4.思想:数组递归去重12345678910111213141516171819var arr = [12, 5, 8, 12, 6, 4, 8, 5, 3];Array.prototype.removal = function ()&#123; var arr1 = this, len = arr1.length; arr1.sort(function(a,b)&#123; //对数组进行排序才能方便比较 return a - b; &#125;) function loop(index)&#123; if(index &gt;= 1)&#123; if(arr1[index] === arr1[index-1])&#123; arr1.splice(index,1); &#125; loop(index - 1); //递归loop函数进行去重 &#125; &#125; loop(len-1); return arr1;&#125;;console.log(arr.removal()) // [12,5,8,6,4,3] 5.思想:利用indexOf以及forEach1234567891011121314var arr = [12, 5, 8, 12, 6, 4, 8, 5, 3];Array.prototype.removal = function ()&#123; var arr = this, result = [], len = arr.length; arr.forEach(function(v, i ,arr)&#123; //这里利用map，filter方法也可以实现 var bool = arr.indexOf(v,i+1); //从传入参数的下一个索引值开始寻找是否存在重复 if(bool === -1)&#123; result.push(v); &#125; &#125;) return result;&#125;;console.log(arr.removal()) // [12,5,8,6,4,3] 6.思想:利用ES6的setSet数据结构，它类似于数组，其成员的值都是唯一的。利用Array.from将Set结构转换成数组1234function dedupe(array)&#123; return Array.from(new Set(array));&#125;dedupe([1,1,2,3]) //[1,2,3] Array.from() 使用方法1Array.from(arrayLike, mapFn, thisArg) 参数 arrayLike想要转换成数组的伪数组对象或可迭代对象。 mapFn (可选参数)如果指定了该参数，新数组中的每个元素会执行该回调函数。 thisArg (可选参数)可选参数，执行回调函数 mapFn 时 this 对象。返回值一个新的数组实例]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 Modules]]></title>
    <url>%2FES6-Modules%2F</url>
    <content type="text"><![CDATA[ES6正式提出了内置的模块化语法，我们在浏览器端无需额外引入requirejs来进行模块化 。 ES6中的模块有以下特点： 模块自动运行在严格模式下 在模块的顶级作用域创建的变量，不会被自动添加到共享的全局作用域，它们只会在模块顶级作用域的内部存在； 模块顶级作用域的 this 值为 undefined 对于需要让模块外部代码访问的内容，模块必须导出它们 定义模块使用 export 关键字将任意变量、函数或者类公开给其他模块。123456789101112131415161718192021222324//导出变量export var color = "red";export let name = "cz";export const age = 25;//导出函数export function add(num1,num2)&#123; return num1+num2;&#125;//导出类export class Rectangle &#123; constructor(length, width) &#123; this.length = length; this.width = width; &#125;&#125;function multiply(num1, num2) &#123; return num1 * num2;&#125;//导出对象，即导出引用export &#123;multiply&#125; 重命名模块重命名想导出的变量、函数或类的名称12345function sum(num1, num2) &#123; return num1 + num2;&#125;export &#123;sum as add&#125; 这里将本地的sum函数重命名为add导出，因此在使用此模块的时候必须使用add这个名称。 导出默认值模块的默认值是使用 default 关键字 所指定的单个变量、函数或类，而你在每个模块中 只能设置一个默认导出。 123export default function(num1, num2) &#123; return num1 + num2;&#125; 此模块将一个函数作为默认值进行了导出， default 关键字标明了这是一个默认导出。此函数并不需要有名称，因为它就代表这个模块自身。对比最前面使用export导出的函数，并不是匿名函数而是必须有一个名称用于加载模块的时候使用，但是默认导出则无需一个名字，因为模块名就代表了这个导出值。 也可以使用重命名语法来导出默认值。12345function sum(num1, num2) &#123; return num1 + num2;&#125;export &#123; sum as default &#125;; 加载模块在模块中使用 import 关键字来导入其他模块。import 语句有两个部分，一是需要导入的标识符，二是需导入的标识符的来源模块。此处是导入语句的基本形式：1import &#123; identifier1,identifier2 &#125; from "./example.js" 大括号中指定了从给定模块导入的标识符 from指明了需要导入的模块。模块由一个表示模块路径的字符串来指定。 当从模块导入了一个绑定时，你不能在当前文件中再定义另一个同名变量（包括导入另一个同名绑定），也不能在对应的 import 语句之前使用此标识符，更不能修改它的值。 导入单个绑定如果一个模块只导出了一个函数（或变量或类），或者导出了多个接口但是只选择导入其中的一个，那么就可以写成下面单个导入的模式： 1import &#123;sum&#125; from './example.js' 完全导入一个模块还有一种情况，就是将整个模块当做单一对象导入，该模块的所有导出都会作为对象的属性存在： 123import * as example from './example.js'example.sum(1,2);example.multiply(2,3); 在此代码中， example.js 中所有导出的绑定都被加载到一个名为 example 的对象中，具名导出（ sum() 函数、 multiple() 函数）都成为 example 的可用属性。这种导入格式被称为 命名空间导入 ，这是因为该 example 对象并不存在于 example.js 文件中，而是作为一个命名空间对象被创建使用，其中包含了 example.js 的所有导出成员。1然而要记住，无论你对同一个模块使用了多少次 import 语句，该模块都只会被执行一次。 在导出模块的代码执行之后，已被实例化的模块就被保留在内存中，并随时都能被其他 import 所引用. 123import &#123; sum &#125; from "./example.js";import &#123; multiply &#125; from "./example.js";import &#123; magicNumber &#125; from "./example.js"; 尽管此处的模块使用了三个 import 语句，但 example.js 只会被执行一次。若同一个应用中的其他模块打算从 example.js 导入绑定，则那些模块都会使用这段代码中所用的同一个模块实例。 重命名导入与导出相同，我们同样可以重命名导入的绑定：1import &#123; sum as add&#125; from './example.js' 导入默认值如果一个模块导出了默认值，那么可以这样导入默认值： 1import sum from "./example.js"; 这个导入语句从 example.js 模块导入了其默认值。注意此处并未使用花括号，与之前在非默认的导入中看到的不同。本地名称 sum 被用于代表目标模块所默认导出的函数，因此无需使用花括号。 如果一个模块既导出了默认值、又导出了一个或更多非默认的绑定的模块：12345export let color = "red";export default function(num1, num2) &#123; return num1 + num2;&#125; 可以像下面这样使用一条import语句来导入它的所有导出绑定：1import sum,&#123;color&#125; from "./example.js" 逗号将默认的本地名称与非默认的名称分隔开，后者仍旧被花括号所包裹。要记住在 import 语句中 默认名称必须位于非默认名称之前。 导入的再导出有时想在当前的模块中将已导入的内容再导出去，可以像下面这样写：123import &#123;sum&#125; from './example.js'……export &#123;sum&#125; 但是有一种更简洁的方法： 1export &#123;sum&#125; from './example.js' 同样可以重命名：1export &#123; sum as add &#125; from "./example.js"; 也可以使用完全导出：1export * from "./example.js"; 限制export 与 import 都有一个重要的限制，那就是它们必须被用在其他语句或表达式的外部，而不能使用在if等代码块内部。原因之一是模块语法需要让 JS 能静态判断需要导出什么，正因为此，你只能在模块的顶级作用域使用 export与import。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 Array扩展]]></title>
    <url>%2Fes6%E6%96%B0%E5%A2%9Earray%2F</url>
    <content type="text"><![CDATA[find : 1234567let arr=[1,2,234,'sdf',-2];arr.find(function(x)&#123; return x&lt;=2;&#125;)//结果：1，返回第一个符合条件的x值arr.find(function(x,i,arr)&#123; if(x&lt;2)&#123;console.log(x,i,arr)&#125;&#125;)//结果：1 0 [1, 2, 234, "sdf", -2]，-2 4 [1, 2, 234, "sdf", -2] find的参数为回调函数，回调函数可以接收3个参数，值x、索引i、数组arr，回调函数默认返回值x。 findIndex :1234567let arr=[1,2,234,'sdf',-2];arr.findIndex(function(x)&#123; return x&lt;=2;&#125;)//结果：0，返回第一个符合条件的x值的索引arr.findIndex(function(x,i,arr)&#123; if(x&lt;2)&#123;console.log(x,i,arr)&#125;&#125;)//结果：1 0 [1, 2, 234, "sdf", -2]，-2 4 [1, 2, 234, "sdf", -2] findIndex和find差不多，不过默认返回的是索引。 includes :1234let arr=[1,2,234,'sdf',-2];arr.includes(2);// 结果true，返回布尔值arr.includes(20);// 结果：false，返回布尔值arr.includes(2,3)//结果：false，返回布尔值 includes函数与string的includes一样，接收2参数，查询的项以及查询起始位置。 keys :1234let arr=[1,2,234,'sdf',-2];for(let a of arr.keys())&#123; console.log(a)&#125;//结果：0,1,2,3,4 遍历了数组arr的索引 keys，对数组索引的遍历 values :1234let arr=[1,2,234,'sdf',-2];for(let a of arr.values())&#123; console.log(a)&#125;//结果：1,2,234,sdf,-2 遍历了数组arr的值 values，对数组项的遍历 entries :1234567let arr=['w','b'];for(let a of arr.entries())&#123; console.log(a)&#125;//结果：[0,w],[1,b]for(let [i,v] of arr.entries())&#123; console.log(i,v)&#125;//结果：0 w,1 b entries，对数组键值对的遍历。 fill :1234let arr=['w','b'];arr.fill('i')//结果：['i','i']，改变原数组arr.fill('o',1)//结果：['i','o']改变原数组,第二个参数表示填充起始位置new Array(3).fill('k').fill('r',1,2)//结果：['k','r','k']，第三个数组表示填充的结束位置 fill方法改变原数组，当第三个参数大于数组长度时候，以最后一位为结束位置。 Array.of() :1234Array.of('w','i','r')//["w", "i", "r"]返回数组Array.of(['w','o'])//[['w','o']]返回嵌套数组Array.of(undefined)//[undefined]依然返回数组Array.of()//[]返回一个空数组 Array.of()方法永远返回一个数组，参数不分类型，只分数量，数量为0返回空数组。 copyWithin :1234["w", "i", "r"].copyWithin(0)//此时数组不变["w", "i", "r"].copyWithin(1)//["w", "w", "i"],数组从位置1开始被原数组覆盖，只有1之前的项0保持不变["w", "i", "r","b"].copyWithin(1,2)//["w", "r", "b", "b"],索引2到最后的r,b两项分别替换到原数组1开始的各项，当数量不够，变终止["w", "i", "r",'b'].copyWithin(1,2,3)//["w", "r", "r", "b"]，强第1项的i替换为第2项的r copyWithin方法接收三个参数，被替换数据的开始处、替换块的开始处、替换块的结束处(不包括);copyWithin(s,m,n). Array.from() :12345678910Array.from(&#123;'0':'w','1':'b',length:2&#125;)//["w", "b"],返回数组的长度取决于对象中的length，故此项必须有！Array.from(&#123;'0':'w','1':'b',length:4&#125;)//["w", "b", undefined, undefined],数组后2项没有属性去赋值，故undefinedArray.from(&#123;'0':'w','1':'b',length:1&#125;)//["w"],length小于key的数目，按序添加数组//////////////////////////////let divs=document.getElementsByTagName('div');Array.from(divs)//返回div元素数组Array.from('wbiokr')//["w", "b", "i", "o", "k", "r"]Array.from([1,2,3],function(x)&#123; return x+1&#125;)//[2, 3, 4],第二个参数为回调函数 Array.from可以把带有lenght属性类似数组的对象转换为数组，也可以把字符串等可以遍历的对象转换为数组，它接收2个参数，转换对象与回调函数]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Es6</tag>
        <tag>JavaScript Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String字符串方法]]></title>
    <url>%2FString%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. charAt()1str.charAt(n) 返回字符串的第 n 个字符，如果不在 0~str.length-1之间，则返回一个空字符串。 2. indexOf()1indexOf(substr[,start]) 返回 substr 在字符串 str 中首次出现的位置,从 start 位置开始查找，如果不存在，则返回 -1。 start可以是任意整数，默认值为 0。如果 start &lt; 0 则查找整个字符串（如同传进了 0）。如果 start &gt;= str.length，则该方法返回 -1，除非被查找的字符串是一个空字符串，此时返回 str.length.12345var str = "javascript";str.indexOf('s'); // 1str.indexOf('s',6); // -1str.indexOf('',11); // 10str.indexOf('',8); // 8 3. lastIndexOf()1lastIndexOf(substr[,start]) 返回 substr 在字符串 str 中最后出现的位置,从 start 位置 向前开始查找，如果不存在，则返回 -1。1'lastindex'.lastIndexOf('a'); // 1 4. substring()1str.substring(start[, end]) 返回从 start 到 end（不包括）之间的字符，start、end均为 非负整数。若结束参数(end)省略，则表示从start位置一直截取到最后。1234var str = 'abcdefg';str.substring(1, 4); //"bcd"str.substring(1); // "bcdefg"str.substring(-1); //"abcdefg" 传入负值时会视为0 5. slice()1str.slice(start[,end]) 返回从 start 到 end （不包括）之间的字符，可传负值12var str = 'this is awesome';str.slice(4, -1); //" is awesom" 6. substr()1str.slice(start[,end]) 返回 str 中从指定位置开始到指定长度的子字符串，start可为负值 123var str = "Just give me a reason";str.substr(5, 10); // "give me a "str.substr(-4, 2); // "as" 7.replace()1str.replace(regexp|substr, newSubStr|function) 替换 str 的子字符串12var str = "do you love me";str.replace('love','hate'); // "do you hate me" 8. search()1str.search(regexp) 查找 str 与一个正则表达式是否匹配。如果匹配成功，则返回正则表达式在字符串中首次匹配项的索引；否则，返回 -1。如果参数传入的是一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象12345var str = 'I love JavaScript!';str.search(/java/); // -1str.search(/Java/); // 7str.search(/java/i); // 7str.search('Java'); // 7 9. match()1str.match(regexp) 返回一个包含匹配结果的数组，如果没有匹配项，则返回 null。如果参数传入的是一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象1234var str = 'Javascript java';str.match(/Java/); // ["Java"]str.match(/Java/gi); // ["java", "Java"]str.match(/ab/g); // null 10. split()1str.split([separator][, limit]) 返回一个数组，分隔符 separator 可以是一个字符串或正则表达式12345var str = "Hello?World!";str.split(); // ["Hello?World!"]str.split(''); // ["H", "e", "l", "l", "o", "?", "W", "o", "r", "l", "d", "!"]str.split('?'); // ["Hello", "World!"]str.split('',5); // ["H", "e", "l", "l", "o"] 11. trim()1str.trim() 去除 str 开头和结尾处的空白字符，返回 str 的一个副本，不影响字符串本身的值123var str = ' abc ';str.trim(); // 'abc'console.log(str); // ' abc ' 12. toLowerCase()1str.toLowerCase() 将 str 转换为小写，并返回 str 的一个副本，不影响字符串本身的值123var str = 'JavaScript';str.toLowerCase(); // 'javascript'console.log(str); // 'JavaScript' 13. toUpperCase()1str.toUpperCase() 将 str 转换为大写，并返回 str 的一个副本，不影响字符串本身的值123var str = 'JavaScript';str.toUpperCase(); // 'JAVASCRIPT'console.log(str); // 'JavaScript']]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6新增语法]]></title>
    <url>%2FES6%E6%96%B0%E5%A2%9E%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[let,constlet命令的用法类似于var，用来声明变量。可以把let看成var，只是它定义的变量被限定在了特定范围内才能使用，而离开这个范围则无效。123456&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。12const PI = Math.PIPI = 23 //Module build failed: "PI" is read-only class 定义 类类实际上是个“特殊的函数”，就像你能够定义的函数表达式和函数声明一样，类语法有两个组成部分：类表达式和类声明 类声明定义一个类的一种方法是使用一个类声明。要声明一个类，你可以使用带有class关键字的类名（这里是“Rectangle”）。123456class Rectangle &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125;&#125; 箭头函数ES6允许使用“箭头”（=&gt;）定义函数1234567var f = v =&gt; v;//上面的箭头函数等于:var f = function(v)&#123; return v;&#125; 箭头函数除了能简化代码，还有更大的好处：减少this的使用。箭头函数内部没有constructor方法，也没有prototype，所以不支持new操作。但是它对this的处理与一般的普通函数不一样。 箭头函数的 this 始终指向函数定义时的 this，而非执行时。 例如:1234567891011var o = &#123; x : 1, func : function() &#123; console.log(this.x) &#125;, test : function() &#123; setTimeout(function() &#123; this.func(); &#125;, 100); &#125;&#125;;o.test(); // TypeError : this.func is not a function 上面的代码会出现错误，因为this的指向从o变为了全局（函数调用中的this都是指向全局的）。我们需要使用外部变量事先保存this，修改上面的代码如下：123456789101112var o = &#123; x : 1, func : function() &#123; console.log(this.x) &#125;, test : function() &#123; var _this = this; setTimeout(function() &#123; _this.func(); &#125;, 100); &#125;&#125;;o.test(); 这段代码如果使用箭头函数，就不需要使用this，因为箭头函数的 this 始终指向函数定义时的 this，而非执行时。所以我们将上面的代码修改如下：123456789var o = &#123; x : 1, func : function() &#123; console.log(this.x) &#125;, test : function() &#123; setTimeout(() =&gt; &#123; this.func() &#125;, 100); &#125;&#125;;o.test(); 字符串模板（反引号 `）ES6中提供了用反引号｀来创建字符串，里面可包含${…}，即在字符串中可以添加变量12let name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` rest, spread扩展运算符（ spread ）和Rest操作符都是用三个点（…）表示，但作用整好相反。Rest操作符一般用在函数参数的声明中，而扩展运算符用在函数的调用中。1234function func(...args)&#123; console.log(args);//[1,2,3,4]&#125;func(1,2,3,4); for…offor…of(这里先记录一下之后在深入了解一下)1234let arr = [1,2,3];for (let itr of arr) &#123; console.log(itr); //1 2 3&#125; Map, Set(依然是先做记录之后深入了解)ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。12345四个操作方法：add(value)：添加某个值，返回Set结构本身。delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。has(value)：返回一个布尔值，表示该值是否为Set的成员。clear()：清除所有成员，没有返回值 Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 12345678//实例属性和方法：size、set、get、has、delete、clearlist = supportList.map( (item,index) =&gt; &lt;option key=&#123;item.a&#125; value=&#123;item.b&#125;&gt; &#123;item.c&#125; &lt;/option&gt; ); Symbols(目前我也不知道是做什么用的,先记录一下吧!)Symbol 是一种新的数据类型，它的值是唯一的，不可变的。ES6 中提出 symbol 的目的是为了生成一个唯一的标识符，不过你访问不到这个标识符.12var sym = Symbol( "Symbol" );console.log(typeof sym); // symbol 如果要获取对象 symbol 属性，需要使用Object.getOwnPropertySymbols(o) Iterators（迭代器）(先记录,之后深入了解一下)ES6 中可以通过 Symbol.iterator 给对象设置默认的遍历器，直到状态为true退出。1234567var arr = [11,12,13];var itr = arr[Symbol.iterator]();itr.next(); //&#123; value: 11, done: false &#125;itr.next(); //&#123; value: 12, done: false &#125;itr.next(); //&#123; value: 13, done: false &#125;itr.next(); //&#123; value: undefined, done: true &#125; 解构(值得深入了解一下…)解构赋值是ES6中推出的一种高效、简洁的赋值方法123456789101112//通常情况下var arr = [1,2,3];var first = arr[0];var two = arr[1];var three = arr[2];//解构赋值let [first, two, three] = arr;//first = 1;//two = 2;//three = 3;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之字符串扩展方法(常用)]]></title>
    <url>%2FES6%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95(%E5%B8%B8%E7%94%A8)%2F</url>
    <content type="text"><![CDATA[includesincludes是判断是否包含的,直接返回布尔值123456let str='google';if(str.includes('o'))&#123; console.log('yes');&#125;else&#123; console.log('no');&#125; startsWith ，endsWithstartsWith用于判断是否位于头部，endsWith判断是否位于尾部，可以说这两个方法是includes方法的扩展；12345let str='google';console.log(str.startsWith('g')); //trueconsole.log(str.endsWith('e')); //true repeat顾名思义，这个方法就是可以获取字符串重复N次后的方法；12let str='google';console.log(str.repeat(3)); //googlegooglegoogle repeat方法接受一个数字类型的参数，可以是正式也可以是小数，如果是浮点型会自动调用Math.floor方法转为整型；123let str='google';console.log(str.repeat(3.5)); //googlegooglegoogleconsole.log(str.repeat(Math.floor(3.5)));//googlegooglegoogle 参数可以为0这样就会返回一个空字符串，但是不能为负数，否则会报错；123let str='google';console.log(str.repeat(0)); //''console.log(str.repeat(-3.5));//RangeError: Invalid count value padStart,padEnd这两个方法其实是ES7标准下扩展的方法，作用就是自动补全；12345let str='goo';&lt;br&gt; str.padStart(5, 'le') // 'legoo'str.padStart(4, 'le') // 'lgoo'str.padEnd(5, 'le') // 'goole'str.padEnd(4, 'le') // 'gool' 这两个方法类似都是接受两个参数，第一个是补全的长度，第二个是要补充的内容，由于是es7标准的方法，现在浏览器还不能直接运行，可以尝试借助babel运行；]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CommonJS规范]]></title>
    <url>%2FCommonJS%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[定义模块在每个模块内部，module变量代表当前模块。它的exports属性是对外的接口，将模块的接口暴露出去。其他文件加载该模块，实际上就是读取module.exports变量。 123456var x = 5;var addX = function (value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX; 加载模块require方法用于加载模块，后缀名默认为.js 1var app = require('./app.js'); 模块加载的顺序，按照其在代码中出现的顺序 根据参数的不同格式，require命令去不同路径寻找模块文件。1) 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。2) 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径的模块文件3) 如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（node核心模块，或者通过全局安装或局部安装在node_modules目录中的模块） 入口文件一般都会有一个主文件（入口文件），在index.html中加载这个入口文件，然后在这个入口文件中加载其他文件。 可以通过在package.json中配置main字段来指定入口文件。 模块缓存第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性。 加载机制CommonJS模块的加载机制是， 输入的是被输出的值的拷贝。 也就是说， 一旦输出一个值，模块内部的变化就影响不到这个值。 CommonJS 规范 CommonJs规范的出发点：JS没有模块系统、标准库较少、缺乏包管理工具；为了让JS可以在任何地方运行，以达到Java、C#、PHP这些后台语言具备开发大型应用的能力； 在CommonJs规范中： 一个文件就是一个模块，拥有单独的作用域； 普通方式定义的变量、函数、对象都属于该模块内； 通过require来加载模块； 通过exports和modul.exports来暴露模块中的内容； 所有代码都运行在模块作用域，不会污染全局作用域；模块可以多次加载，但只会在第一次加载的时候运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果；模块的加载顺序，按照代码的出现顺序是同步加载的; dirname代表当前模块文件所在的文件夹路径，filename代表当前模块文件所在的文件夹路径+文件名; require（同步加载）基本功能：读取并执行一个JS文件，然后返回该模块的exports对象，如果没有发现指定模块会报错; 模块内的exports：为了方便，node为每个模块提供一个exports变量，其指向module.exports，相当于在模块头部加了这句话：var exports = module.exports，在对外输出时，可以给exports对象添加方法，PS：不能直接赋值（因为这样就切断了exports和module.exports的联系）; npm root -g：查看npm全局包安装位置，建议在nvm目录下新建npm\node_modules目录，然后设置npm的全局包安装位置：npm config set prefix “”，然后将该路径添加到环境变量中; npm init -y：初始化一个package.json文件，加上-y就会默认生成该文件，无需一步一步填写；npm docs 包名：查看包的文档；npm install：安装package.json中dependencies属性中所有依赖的包 由于npm的服务器是国外的，所以如果你没有和谐工具是下载不了的，这里推荐使用淘宝NPM镜像：http://npm.taobao.org/，与官方NPM的同步频率目前为10分钟一次；安装命令：npm install -g cnpm –registry=https://registry.npm.taobao.org，安装包：cnpm install 包名（其它命令基本一致）; 如果你不想下载cnpm，npm还提供了一个镜像源管理工具：npm install -g nrm，通过：nrm ls，查看镜像源列表 ，通过：npm use 镜像源，来切换; NPM的模块加载机制： 如果require的是绝对路径文件，查找不会去遍历每个node_modules目录，其速度最快 1）.从module.paths数组中（由当前执行文件目录到磁盘根目录）取出第一个目录作为查找基准 2）.直接从目录中查找该文件，如果存在则结束查找，如果不存在则进行下一条查找 3）.尝试添加.js、.json、.node后缀之后查找，如果存在文件则结束查找，如果不存在则进行下一条查找 4）.尝试将require的参数作为一个包来进行查找，读取目录下的package.json文件，取得Main参数指定的文件 5）.尝试查找该文件，如果存在则结束查找，如果不存在则进行第3条查找 6）.如果继续失败，则取出module.paths数组中的下一目录作为基准查找，循环第1-5个步骤 7）.如果继续失败，循环第1-6个步骤，直到module.paths中的最后一个值 8）.如果继续失败，则抛出异常]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CommonJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F%E4%BA%8C%E5%8F%89%E6%A0%91-1%2F</url>
    <content type="text"><![CDATA[二叉树的概念12345678二叉树（Binary Tree）是n（n≥0）个结点的有限集合，该集合或者为空集(称为空二叉树),或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。二叉树特点：1.每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。没有子树或者有一棵子树 是可以的，最多有两棵子树。2.左子树和右子树是有顺序的，次序不能颠倒。3.即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。 二叉树具有五种基本形态：1.空二叉树；2.只有一个根结点；3.根结点只有左子树；4.根结点只有右子树；5.根结点既有左子树又有右子树。 特殊二叉树斜树所有的结点都只有左子树的二叉树叫 左斜树 。所有的结点都是只有右子树的二叉树叫 右斜树。这二者统称为斜树。斜树有明显特点，每一层都只有一个结点，结点的个数和二叉树的深度相同。斜树和线性表结构一样，线性表结构是树的一种特殊表现形式。 满二叉树在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。单是每个节点都存在左右子树，不能算是满n二叉树，还必须要所有的叶子结点都在同一层上，这样就做到了整棵树的平衡。所以，满二叉树的特点是：1.叶子只能出现在最下一层，出现在其他层就不能达到平衡；2.非叶子结点的度一定是2；3.在同样深度的二叉树中，满二叉树的结点最多，叶子数最多。 完全二叉树对一棵具有n个结点的二叉树 按层序编号 ，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这颗二叉树称为完全二叉树。 完全二叉树的特性：（1）叶子结点只能出现在最下两层。（2）最下层的叶子一定集中在左部连续位置。（3）倒数第二层，若有叶子结点，一定都在右部连续位置。（4）如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。（5）同样结点数的二叉树，完全二叉树的深度最小。 二叉树的性质性质一：在二叉树的第i层上至多有 2i−1 个结点（i≥1）。—–归纳法 性质二：深度为k的二叉树至多有 2k−1 个结点（k≥1）。—–归纳法 性质三：对任何一棵二叉树T，如果其终端结点数为 n0，度为2的结点数为 n2，则 n0=n2+1。123设 n1 为度是1的结点数，那么T结点总数 n=n0+n1+n2.换个角度，数数连接连线，因为根结点只有分支出去，没有分支进入，所以分支线总数为结点总数减去1，分支线总数为 n−1=n1+2n2 ，两个式子相减得到 n0=n2+1。 性质四：具有n个结点的完全二叉树的深度为 |log2n|+1（其中|x|表示不大于x的最大整数）。 性质五：如果对一棵有n个结点的完全二叉树（深度为 |log2n|+1）的结点按层序编号（从第1层到第 |log2n|+1层，每层从左到右），对任一结点i（1≤i≤n）有：1.如果 i=1，则结点i是二叉树的根，无双亲；如果 i&gt;1，则其双亲是结点|i/2|。2.如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。3.如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1。 二叉树的存储结构二叉树顺序存储结构二叉树比较特殊，所以可以使用顺序存储结构可以实现。二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，例如双亲与孩子的关系，左右兄弟的关系等等。完全二叉树的存储可以根据结点的编号来存储，一般的二叉树，尽管层序编号不能反映逻辑关系，但是可按完全二叉树编号，将不存在的结点设置为“∧”。若是考虑极端情况，例如右斜树，k个结点，却分配 2k−1 个存储单元空间，浪费了存储空间。所以，顺序存储结构一般只用于完全二叉树。 二叉树的遍历例如: 先序遍历：ABCDEFGHK 中序遍历：BDCAEHGKF 后序遍历：DCBHKGFEA 以中序遍历为例： 中序遍历的规则是【左根右】，我们从root节点A看起； 此时A是根节点，遍历A的左子树； A的左子树存在，找到B，此时B看做根节点，遍历B的左子树； B的左子树不存在，返回B，根据【左根右】的遍历规则，记录B，遍历B的右子树； B的右子树存在，找到C，此时C看做根节点，遍历C的左子树； C的左子树存在，找到D，由于D是叶子节点，无左子树，记录D，无右子树，返回C，根据【左根右】的遍历规则，记录C，遍历C的右子树； C的右子树不存在，返回B，B的右子树遍历完，返回A； 至此，A的左子树遍历完毕，根据【左根右】的遍历规则，记录A，遍历A的右子树； A的右子树存在，找到E，此时E看做根节点，遍历E的左子树； E的左子树不存在，返回E，根据【左根右】的遍历规则，记录E，遍历E的右子树； E的右子树存在，找到F，此时F看做根节点，遍历F的左子树； F的左子树存在，找到G，此时G看做根节点，遍历G的左子树； G的左子树存在，找到H，由于H是叶子节点，无左子树，记录H，无右子树，返回G，根据【左根右】的遍历规则，记录G，遍历G的右子树； G的右子树存在，找到K，由于K是叶子节点，无左子树，记录K，无右子树，返回G，根据【左根右】的遍历规则，记录F，遍历F的右子树； F的右子树不存在，返回F，E的右子树遍历完毕，返回A； 至此，A的右子树也遍历完毕； 最终我们得到上图的中序遍历为BDCAEHGKF，无非是按照遍历规则来的； 根据“中序遍历”的分析，相信先序遍历和后序遍历也可以轻松写出~]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23条前端性能优化]]></title>
    <url>%2F23%E6%9D%A1%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前端性能优化是个巨大的课题，如果要面面俱到的说的话，估计三天三夜说不完。所以我们就从实际的工程应用角度出发，聊我们最常遇见的前端优化问题。 1. 减少HTTP请求次数尽量合并图片、CSS、JS。比如加载一个页面，如果有5个css文件的话，那么会发出5次http请求，这样会让用户第一次访问你的页面的时候会长时间等待。而如果把这个5个文件合成一个的话，就只需要发出一次http请求，节省网络请求时间，加快页面的加载。 2. 使用CDN网站上静态资源即css、js全都使用cdn分发，图片亦然。 3. 避免空的src和href当link标签的href属性为空、script标签的src属性为空的时候，浏览器渲染的时候会把当前页面的URL作为它们的属性值，从而把页面的内容加载进来作为它们的值。所以要避免犯这样的疏忽。 4. 为文件头指定ExpiresExipres是用来设置文件的过期时间的，一般对css、js、图片资源有效。 他可以使内容具有缓存性，这样下回再访问同样的资源时就通过浏览器缓存区读取，不需要再发出http请求。如下例子：新浪微博的这个css文件的Expires时间是2016-5-04 09:14:14 5. 使用gzip压缩内容gzip能够压缩任何一个文本类型的响应，包括html，xml，json。大大缩小请求返回的数据量。 6. 把CSS放到顶部网页上的资源加载时从上网下顺序加载的，所以css放在页面的顶部能够优先渲染页面，让用户感觉页面加载很快。 7. 把JS放到底部加载js时会对后续的资源造成阻塞，必须得等js加载完才去加载后续的文件 ，所以就把js放在页面底部最后加载。 8. 避免使用CSS表达式举个css表达式的例子1font-color:expression((new Date()).getHours()%3 ? "#fff" : "#aaa"); 这个表达式会持续的在页面上计算样式，影响页面的性能。并且css表达式只被IE支持。 9. 将CSS和JS放到外部文件中目的是缓存文件，可以参考原则4。 但有时候为了减少请求，也会直接写到页面里，需根据PV和IP的比例权衡。 10. 权衡DNS查找次数减少主机名可以节省响应时间。但同时，需要注意，减少主机会减少页面中并行下载的数量。IE浏览器在同一时刻只能从同一域名下载两个文件。当在一个页面显示多张图片时，IE 用户的图片下载速度就会受到影响。所以新浪会搞N个二级域名来放图片。 1.精简CSS和JS这里就涉及到css和js的压缩了。比如下面的新浪的一个css文件，把空格回车全部去掉，减少文件的大小。现在的压缩工具有很多，基本主流的前端构建工具都能进行css和js文件的压缩，如grunt，glup等。 12. 避免跳转有种现象会比较坑爹，看起来没什么差别，其实多次了一次页面跳转。比如当URL本该有斜杠（/）却被忽略掉时。例如，当我们要访问 http:// baidu.com 时，实际上返回的是一个包含301代码的跳转，它指向的是 http:// baidu.com/ （注意末尾的斜杠）。在nginx服务器可以使用rewrite；Apache服务器中可以使用Alias 或者 mod_rewrite或者the DirectorySlash来避免。另一种是不用域名之间的跳转， 比如访问 http:// baidu.com/bbs 跳转到 http:// bbs.baidu.com/ 。那么可以通过使用Alias或者mod_rewirte建立CNAME（保存一个域名和另外一个域名之间关系的DNS记录）来替代。 13. 删除重复的JS和CSS重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。 14. 配置ETags它用来判断浏览器缓存里的元素是否和原来服务器上的一致。比last-modified date更具有弹性，例如某个文件在1秒内修改了10次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载 15. 可缓存的AJAX异步请求同样的造成用户等待，所以使用ajax请求时，要主动告诉浏览器如果该请求有缓存就去请求缓存内容。如下代码片段, cache:true就是显式的要求如果当前请求有缓存的话，直接使用缓存 1234567$.ajax(&#123; url : 'url', dataType : "json", cache: true, success : function(son, status)&#123;&#125;, error : function()&#123;&#125;&#125;) 16. 使用GET来完成AJAX请求当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。因此使用GET获取数据时更加有意义。 17. 减少DOM元素数量这是一门大学问，这里可以引申出一堆优化的细节。想要具体研究的可以看后面推荐书籍。总之大原则减少DOM数量，就会减少浏览器的解析负担。 18. 避免404比如外链的css、js文件出现问题返回404时，会破坏浏览器的并行加载。 19. 减少Cookie的大小Cookie里面别塞那么多东西，因为每个请求都得带着他跑。 20. 使用无cookie的域比如CSS、js、图片等，客户端请求静态文件的时候，减少了 Cookie 的反复传输对主域名的影响。 21. 不要使用滤镜IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。 22. 不要在HTML中缩放图片比如你需要的图片尺寸是50 50，那就不用用一张500500的大尺寸图片，影响加载（说到这里可能有朋友会说了，后台上传的图片我也没办法控制他上传的尺寸啊，这里只是说的最开始做静态页面的时候的一些注意事项，至于后面怎么去操作，那就看网编怎么办了，尽可能把自己能做的做到最好就行了） 23. 缩小favicon.ico并缓存以上是Yslow的23个优化原则，基本可以涵盖现在前端大部分的性能优化原则了，很多更加geek和精细优化方法都是从这些原则里面延伸出来的。 前端优化是条漫长的路，不是说一天两天就能全部做完的。我们可以参考上面的准则去把我们目前能做的都给优化了，剩下的更加小的一些细节点不用太过着急，毕竟也是要考虑优化性价比的。比如为了减小一个文件几个字节花上个把月根本不值得。这些优化的东西都可以在我们的工作中慢慢去通过积累，去通过google解决。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2FAjax%2F</url>
    <content type="text"><![CDATA[ajax 的全称是Asynchronous JavaScript and XML，其中，Asynchronous 是异步的意思，它有别于传统web开发中采用的同步的方式。 ajax原理和XmlHttpRequest对象 Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。 XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。 首先，我们先来看看XMLHttpRequest这个对象的属性。 它的属性有： onreadystatechange 每次状态改变所触发事件的事件处理程序。 responseText 从服务器进程返回数据的字符串形式。 responseXML 从服务器进程返回的DOM兼容的文档数据对象。 status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪） status Text 伴随状态码的字符串信息 readyState 对象状态值 0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法） 1 (初始化) 对象已建立，尚未调用send方法 2 (发送数据) send方法已调用，但是当前的状态及http头未知 3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误， 4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据 但是，由于各浏览器之间存在差异，所以创建一个XMLHttpRequest对象可能需要不同的方法。这个差异主要体现在IE和其它浏览器之间。下面是一个比较标准的创建XMLHttpRequest对象的方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//创建传输对象function createXHR()&#123; if(window.XMLHttpRequest)&#123; return new XMLHrrpRequest(); &#125; return new ActiveXObject("Microsoft.XMLHTTP");&#125;//obj &#123;name:huhu,age:18&#125; =&gt; "name=huhu&amp;age=18"//格式化参数function params(obj) &#123; var arr = []; for(var i in obj) &#123; var str = i + "=" + obj[i]; arr.push(str); &#125; arr.push(("v=" + Math.random()).replace(".", "")); return arr.join("&amp;");&#125;function ajax(option)&#123; option = option || &#123;&#125;; option.url = option.url || ''; option.type = option.type.toUpperCase() || 'GET'; option.data = option.data || ''; option.async = option.async || true; option.success = option.success || function (data) &#123;&#125;; option.error = option.errro || function (data) &#123;&#125;; // 第一步 创建对象 var xhr = createXHR(); //连接 和 发送 - 第二步 if (option.type == "GET") &#123; xhr.open("GET", option.url + "?" + params(option.data), option.async); xhr.send(null); &#125; else if (option.type == "POST") &#123; xhr.open("POST", option.url, option.async); //设置表单提交时的内容类型 xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); xhr.send(params(option.data)); &#125;else&#123; alert('类型有误') return; &#125; xhr.onreadystatechange = function () &#123; if (XHR.readyState == 4) &#123; var status = xhr.status; if (XHR.status &gt;= 200 &amp;&amp; XHR.status &lt; 300 || XHR.status == 304) &#123; switch (obj.responseType) &#123; case 'document': obj.success(XHR.responseXML); break; case 'json': obj.success(XHR.response); break; default: obj.success(XHR.responseText); break; &#125; &#125;else&#123; option.error(status); &#125; &#125; &#125;&#125;/* 使用 ajax(&#123; type:请求的方式 get/post 如果省略 默认是get, url:不能省略 必须参数 服务器地址, data:&#123;&#125; 参数 如果没有参数省略即可, async: ture/false 是否是异步 默认不写就是异步, success:function(data)&#123;&#125; 请求成功的回调函数 data表示请求回来的数据, error:function(data)&#123;&#125; 请求失败的回调函数, responseType:document(请求xml数据) json(请求json数据) text 如果省略默认返回text &#125;);*/ 还有其他封装方法 不一一列出了~ Ajax的缺点下面所阐述的ajax的缺陷都是它先天所产生的。 1、ajax干掉了back按钮，即对浏览器后退机制的破坏。后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。这是ajax所带来的一个比较严重的问题，因为用户往往是希望能够通过后退来取消前一次操作的。那么对于这个问题有没有办法？答案是肯定的，用过Gmail的知道，Gmail下面采用的ajax技术解决了这个问题，在Gmail下面是可以后退的，但是，它也并不能改变ajax的机制，它只是采用的一个比较笨但是有效的办法，即用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的IFRAME来重现页面上的变更。（例如，当用户在Google Maps中单击后退时，它在一个隐藏的IFRAME中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态。） 但是，虽然说这个问题是可以解决的，但是它所带来的开发成本是非常高的，和ajax框架所要求的快速开发是相背离的。这是ajax所带来的一个非常严重的问题。 2、安全问题 技术同时也对IT企业带来了新的安全威胁，ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于credentials的安全漏洞等。 3、对搜索引擎的支持比较弱。 4、破坏了程序的异常机制。至少从目前看来，像ajax.dll，ajaxpro.dll这些ajax框架是会破坏程序的异常机制的。关于这个问题，我曾经在开发过程中遇到过，但是查了一下网上几乎没有相关的介绍。后来我自己做了一次试验，分别采用ajax和传统的form提交的模式来删除一条数据……给我们的调试带来了很大的困难。 5、另外，像其他方面的一些问题，比如说违背了url和资源定位的初衷。例如，我给你一个url地址，如果采用了ajax技术，也许你在该url地址下面看到的和我在这个url地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。 6、一些手持设备（如手机、PDA等）现在还不能很好的支持ajax，比如说我们在手机的浏览器上打开采用ajax技术的网站时，它目前是不支持的，当然，这个问题和我们没太多关系。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class 类--初识]]></title>
    <url>%2FClass-%E7%B1%BB-%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[类的声明 定义一个类的一种方法是使用一个类声明。要声明一个类，你可以使用带有class关键字的类名 123456class Remou &#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125; &#125; 不存在变量提升类不存在变量提升（hoist），这一点与 ES5 完全不同。 12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 上面代码中，Foo类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。 12345&#123; let Foo = class &#123;&#125;; class Bar extends Foo &#123; &#125;&#125; 上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。 类的表达式一个 类表达式 是定义一个类的另一种方式。类表达式可以是被命名的或匿名的。赋予一个命名类表达式的名称是类的主体的本地名称。 123456789101112131415//匿名的类let Rou = class &#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125; &#125;//命名的类let Rou = class Remou&#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125; &#125; 注意: 类表达式也同样受到类声明中提到的提升问题的困扰。 类的方法和定义 一个类的类体是一对花括号 {} 中的部分。这是你定义类成员的位置，如方法或构造函数。 严格模式 类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。 考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。 类声明和类表达式的主体都执行在严格模式下。比如，构造函数，静态方法，原型方法，getter和setter都在严格模式下执行。 constructor 方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 1234567class Point &#123;&#125;// 等同于class Point &#123; constructor() &#123;&#125;&#125; 上面代码中，定义了一个空的类Point，JavaScript 引擎会自动为它添加一个空的constructor方法。 constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo// false 上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;Foo()// TypeError: Class constructor Foo cannot be invoked without 'new' 类的实例化对象生成类的实例对象的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。123456789class Point &#123; // ...&#125;// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3); 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。12345678910111213141516171819202122//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // true 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与 ES5 的行为保持一致。 与 ES5 一样，类的所有实例共享一个原型对象。12345var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__ === p2.__proto__//true 上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。这也意味着，可以通过实例的__proto__属性为“类”添加方法。 __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。12345678910var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__.printName = function () &#123; return 'Oops' &#125;;p1.printName() // "Oops"p2.printName() // "Oops"var p3 = new Point(4,2);p3.printName() // "Oops" 上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的proto属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。 Class 表达式与函数一样，类也可以使用表达式的形式定义。12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。123let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined 上面代码表示，Me只在 Class 内部有定义。如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 const MyClass = class { /* ... */ };采用 Class 表达式，可以写出立即执行的 Class。1234567891011let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;('张三');person.sayName(); // "张三" 上面代码中，person是一个立即执行的类的实例。私有方法私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。 一种做法是在命名上加以区别。 1234567891011121314class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // ...&#125; 上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。 1234567891011class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // ...&#125;function bar(baz) &#123; return this.snaf = baz;&#125; 上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。 1234567891011121314151617const bar = Symbol('bar');const snaf = Symbol('snaf');export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // ...&#125;; 上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。 this 的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 12345678910111213class Logger &#123; printName(name = 'there') &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property 'print' of undefined 上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。 1234567class Logger &#123; constructor() &#123; this.printName = this.printName.bind(this); &#125; // ...&#125; 另一种解决方法是使用箭头函数。 123456789class Logger &#123; constructor() &#123; this.printName = (name = 'there') =&gt; &#123; this.print(`Hello $&#123;name&#125;`); &#125;; &#125; // ...&#125; 还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。(目前水平达不到先记录一下) 12345678910111213141516171819function selfish (target) &#123; const cache = new WeakMap(); const handler = &#123; get (target, key) &#123; const value = Reflect.get(target, key); if (typeof value !== 'function') &#123; return value; &#125; if (!cache.has(value)) &#123; cache.set(value, value.bind(target)); &#125; return cache.get(value); &#125; &#125;; const proxy = new Proxy(target, handler); return proxy;&#125;const logger = selfish(new Logger()); name属性由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。 12class Point &#123;&#125;Point.name // "Point" name属性总是返回紧跟在class关键字后面的类名。Class 的取值函数（getter）和存值函数（setter）与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter' 上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。存值函数和取值函数是设置在属性的 Descriptor 对象上的。 1234567891011121314151617181920class CustomHTMLElement &#123; constructor(element) &#123; this.element = element; &#125; get html() &#123; return this.element.innerHTML; &#125; set html(value) &#123; this.element.innerHTML = value; &#125;&#125;var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, "html");"get" in descriptor // true"set" in descriptor // true 上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与 ES5 完全一致。Class 的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 1234567891011class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。 注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。12345678910111213class Foo &#123; static bar () &#123; this.baz(); &#125; static baz () &#123; console.log('hello'); &#125; baz () &#123; console.log('world'); &#125;&#125;Foo.bar() // hello 上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。父类的静态方法，可以被子类继承。 12345678910class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod() // 'hello' 上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。静态方法也是可以从super对象上调用的。 12345678910111213class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too'; &#125;&#125;Bar.classMethod() // "hello, too" Class 的静态属性和实例属性静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。 12345class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1 上面的写法为Foo类定义了一个静态属性prop。 目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。 12345678910// 以下两种写法都无效class Foo &#123; // 写法一 prop: 2 // 写法二 static prop: 2&#125;Foo.prop // undefined new.target 属性new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 12345678910111213141516171819function Person(name) &#123; if (new.target !== undefined) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用 new 命令生成实例'); &#125;&#125;// 另一种写法function Person(name) &#123; if (new.target === Person) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用 new 命令生成实例'); &#125;&#125;var person = new Person('张三'); // 正确var notAPerson = Person.call(person, '张三'); // 报错 上面代码确保构造函数只能通过new命令调用。 Class 内部调用new.target，返回当前 Class。 123456789class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); this.length = length; this.width = width; &#125;&#125;var obj = new Rectangle(3, 4); // 输出 true 需要注意的是，子类继承父类时，new.target会返回子类。 1234567891011121314class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); // ... &#125;&#125;class Square extends Rectangle &#123; constructor(length) &#123; super(length, length); &#125;&#125;var obj = new Square(3); // 输出 false 上面代码中，new.target会返回子类。 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。 1234567891011121314151617class Shape &#123; constructor() &#123; if (new.target === Shape) &#123; throw new Error('本类不能实例化'); &#125; &#125;&#125;class Rectangle extends Shape &#123; constructor(length, width) &#123; super(); // ... &#125;&#125;var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确 上面代码中，Shape类不能被实例化，只能用于继承。 注意，在函数外部，使用new.target会报错。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Es6</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鼠标滚轮事件-1]]></title>
    <url>%2F%E9%BC%A0%E6%A0%87%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6-1%2F</url>
    <content type="text"><![CDATA[滚轮事件 以下便是滚轮事件的兼容写法 123456789101112131415161718192021222324var scrollFunc = function (e) &#123; e = e || window.event; if (e.wheelDelta) &#123; //判断浏览器IE，谷歌滑轮事件 if (e.wheelDelta &gt; 0) &#123; //当滑轮向上滚动时 alert("滑轮向上滚动"); &#125; if (e.wheelDelta &lt; 0) &#123; //当滑轮向下滚动时 alert("滑轮向下滚动"); &#125; &#125; else if (e.detail) &#123; //Firefox滑轮事件 if (e.detail &gt; 0) &#123; //当滑轮向上滚动时 alert("滑轮向上滚动"); &#125; if (e.detail &lt; 0) &#123; //当滑轮向下滚动时 alert("滑轮向下滚动"); &#125; &#125; &#125; //给页面绑定滑轮滚动事件if (document.addEventListener) &#123;//firefox document.addEventListener('DOMMouseScroll', scrollFunc, false);&#125; //滚动滑轮触发scrollFunc方法 //ie 谷歌window.onmousewheel = document.onmousewheel = scrollFunc;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>JavaScript 事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array方法]]></title>
    <url>%2FArray%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[join()join(separator): 将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符。1234var arr = [1,2,3];console.log(arr.join()); // 1,2,3console.log(arr.join("-")); // 1-2-3console.log(arr); // [1, 2, 3]（原数组不变） 通过join()方法可以实现重复字符串，只需传入字符串以及重复的次数，就能返回重复后的字符串，函数如下：12345function repeatString(str, n) &#123;return new Array(n + 1).join(str);&#125;console.log(repeatString("abc", 3)); // abcabcabcconsole.log(repeatString("Hi", 5)); // HiHiHiHiHi push()和pop()push(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。1234567var arr = ["Lily","lucy","Tom"];var count = arr.push("Jack","Sean");console.log(count); // 5console.log(arr); // ["Lily", "lucy", "Tom", "Jack", "Sean"]var item = arr.pop();console.log(item); // Seanconsole.log(arr); // ["Lily", "lucy", "Tom", "Jack"] shift() 和 unshift()shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。unshift:将参数添加到原数组开头，并返回数组的长度 。 这组方法和上面的push()和pop()方法正好对应，一个是操作数组的开头，一个是操作数组的结尾。1234567var arr = ["Lily","lucy","Tom"];var count = arr.unshift("Jack","Sean");console.log(count); // 5console.log(arr); //["Jack", "Sean", "Lily", "lucy", "Tom"]var item = arr.shift();console.log(item); // Jackconsole.log(arr); // ["Sean", "Lily", "lucy", "Tom"] sort()sort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。 在排序时，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， sort()方法比较的也是字符串，因此会出现以下的这种情况：12345var arr1 = ["a", "d", "c", "b"];console.log(arr1.sort()); // ["a", "b", "c", "d"]arr2 = [13, 24, 51, 3];console.log(arr2.sort()); // [13, 24, 3, 51]console.log(arr2); // [13, 24, 3, 51](元数组被改变) 为了解决上述问题，sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数：1234567891011function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;arr2 = [13, 24, 51, 3];console.log(arr2.sort(compare)); // [3, 13, 24, 51] 如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可：1234567891011function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125;&#125;arr2 = [13, 24, 51, 3];console.log(arr2.sort(compare)); // [51, 24, 13, 3] reverse()reverse()：反转数组项的顺序。123var arr = [13, 24, 51, 3];console.log(arr.reverse()); //[3, 51, 24, 13]console.log(arr); //[3, 51, 24, 13](原数组改变) concat()concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。1234var arr = [1,3,5,7];var arrCopy = arr.concat(9,[11,13]);console.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]console.log(arr); // [1, 3, 5, 7](原数组未被修改) 从上面测试结果可以发现：传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。但是如果传入的是一个二维数组呢？123var arrCopy2 = arr.concat([9,[11,13]]);console.log(arrCopy2); //[1, 3, 5, 7, 9, Array[2]]console.log(arrCopy2[5]); //[11, 13] 上述代码中，arrCopy2数组的第五项是一个包含两项的数组，也就是说concat方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当作一项添加到arrCopy2中。 slice()slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。12345678910var arr = [1,3,5,7,9,11];var arrCopy = arr.slice(1);var arrCopy2 = arr.slice(1,4);var arrCopy3 = arr.slice(1,-2);var arrCopy4 = arr.slice(-4,-1);console.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)console.log(arrCopy); //[3, 5, 7, 9, 11]console.log(arrCopy2); //[3, 5, 7]console.log(arrCopy3); //[3, 5, 7]console.log(arrCopy4); //[5, 7, 9] arrCopy只设置了一个参数，也就是起始下标为1，所以返回的数组为下标1（包括下标1）开始到数组最后。arrCopy2设置了两个参数，返回起始下标（包括1）开始到终止下标（不包括4）的子数组。arrCopy3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。arrCopy4中两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2,5)。 splice()splice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。 splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。 12345678910var arr = [1,3,5,7,9,11];var arrRemoved = arr.splice(0,2);console.log(arr); //[5, 7, 9, 11]console.log(arrRemoved); //[1, 3]var arrRemoved2 = arr.splice(2,0,4,6);console.log(arr); // [5, 7, 4, 6, 9, 11]console.log(arrRemoved2); // []var arrRemoved3 = arr.splice(1,1,2,4);console.log(arr); // [5, 2, 4, 4, 6, 9, 11]console.log(arrRemoved3); //[7] indexOf()和 lastIndexOf()indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。在比较第一个参数与数组中的每一项时，会使用全等操作符。123456var arr = [1,3,5,7,7,5,3,1];console.log(arr.indexOf(5)); //2console.log(arr.lastIndexOf(5)); //5console.log(arr.indexOf(5,2)); //2console.log(arr.lastIndexOf(5,4)); //2console.log(arr.indexOf("5")); //-1 forEach()forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。12345678910var arr = [1, 2, 3, 4, 5];arr.forEach(function(x, index, a)&#123;console.log(x + '|' + index + '|' + (a === arr));&#125;);// 输出为：// 1|0|true// 2|1|true// 3|2|true// 4|3|true// 5|4|true map()map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 下面代码利用map方法实现数组中每个数求平方。12345var arr = [1, 2, 3, 4, 5];var arr2 = arr.map(function(item)&#123;return item*item;&#125;);console.log(arr2); //[1, 4, 9, 16, 25] filter()filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。12345var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];var arr2 = arr.filter(function(x, index) &#123;return index % 3 === 0 || x &gt;= 8;&#125;);console.log(arr2); //[1, 4, 7, 8, 9, 10] every()every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。123456789var arr = [1, 2, 3, 4, 5];var arr2 = arr.every(function(x) &#123;return x &lt; 10;&#125;);console.log(arr2); //truevar arr3 = arr.every(function(x) &#123;return x &lt; 3;&#125;);console.log(arr3); // false some()some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。123456789var arr = [1, 2, 3, 4, 5];var arr2 = arr.some(function(x) &#123;return x &lt; 3;&#125;);console.log(arr2); //truevar arr3 = arr.some(function(x) &#123;return x &lt; 1;&#125;);console.log(arr3); // false reduce()和 reduceRight()这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。 传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。 下面代码用reduce()实现数组求和，数组一开始加了一个初始值10。12345var values = [1,2,3,4,5];var sum = values.reduceRight(function(prev, cur, index, array)&#123;return prev + cur;&#125;,10);console.log(sum); //25]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的博客]]></title>
    <url>%2F%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭建之路 业精于勤荒于嬉 行成于思毁于随历时一下午终于是搭建成功了自己的博客,并且能展示出去,真的很开心…&nbsp;&nbsp;&nbsp;&nbsp;自2017年1月就开始搭建自己的博客,却因种种原因只完成一半…&nbsp;而现在却是用了4个小时就完成了,对我而言这个速度是我那个时候不敢相信的.从一点都不会到现在可以自己亲手发一篇博客,鬼知道我经历了什么…上次的失败积累下的经验为这次的成功提供了很大助力. 这里推荐一下我看的教程很好很详细http://www.cnblogs.com/fengxiongZz/p/7707568.html在接下来的时间中我会把我所总结、学习的知识点一一记录在此博客中…]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
